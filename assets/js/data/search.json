[ { "title": "[Effective Java] Item 7", "url": "/posts/Effective-Java-Item-7/", "categories": "Study, Effective Java", "tags": "Java, Effective Java", "date": "2023-02-02 09:00:00 +0900", "snippet": "Effective Java - Item 7💡 다 쓴 객체 참조를 해제하라자바처럼 가비지 컬렉터를 갖춘 언어를 사용하는 경우 메모리 관리에 신경 쓰지 않아도 된다고 생각할 수 있지만, 절대 무시해서는 안된다.import java.util.Arrays;import java.util.EmptyStackException;public class Stack {\tprivate Object[] elements;\tprivate int size = 0;\tprivate static final int DEFAULT_INITIAL_CAPACITY = 16;\t\tpublic Stack() {\t\telements = new Object[DEFAULT_INITIAL_CAPACITY];\t}\t\tpublic void push(Object e) {\t\tensureCapacity();\t\telements[size++] = e;\t}\t\tpublic Object pop() {\t\tif (size == 0) \t\t\tthrow new EmptyStackException();\t\treturn elements[--size];\t}\t\tpublic void ensureCapacity() {\t\tif (elements.length == size) \t\t\telements = Arrays.copyOf(elements, 2 * size + 1);\t}}→ 스택을 구현한 간단한 코드위 코드는 스택을 간단하게 구현한 코드이다.언뜻 보면 아무런 문제가 없는 코드라고 생각하기 쉽지만, 해당 코드에서는 스택에서 꺼내진 객체들을 가비지 컬렉터가 회수하지 않는다.스택이 배열에서 여전히 그 객체들을 참조하고 있기 때문이다. 이렇게 객체 참조를 하나 살려두면 해당 객체 뿐 아니라 그 객체가 참조하고 있는 모든 객체를 회수 하지 못한다.때문에 계속해서 실행된다면 가비지 컬렉션의 활동과 메모리 사용량이 늘어나 성능이 저하된다.메모리 누수가 심한 경우에는 디스크 페이징이나 OutOfMemoryError가 발생하여 예기치 않게 프로그램이 될 수도 있다.이러한 문제의 해법은 바로 다 쓴 객체는 null 처리하여 참조를 해제하는 것이다.public Object pop() {\tif (size == 0)\t throw new EmptyStackException();\tObject result = elements[--size];\telement[size] = null; // 다 쓴 객체 참조 해제\treturn result;}스택은 자체적으로 메모리를 관리하고, 배열의 활성화 영역에 속한 객체 만을 사용하고 비활성화 영역은 사용하지 않는데 가비지 컬렉터는 이 사실을 알 수가 없다. 그렇기 때문에 null 처리를 통해 가비지 컬렉터에게 이 객체를 사용하지 않는다는 것을 알려야 한다.일반적으로 스택처럼 자기 메모리를 직접 관리하는 클래스라면 객체를 다 사용한 즉시 null 처리하여 메모리 누수에 주의해야 한다.다만 항상 모든 객체를 일일이 null 처리를 하는 것은 프로그램을 지저분하게 만들 뿐이므로 객체 참조를 null 처리하는 일은 예외적인 경우여야 한다.객체 참조를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효 범위(Scope) 밖으로 밀어내는 것이다.캐시 역시 자기 메모리를 직접 사용하기 때문에 메모리 누수를 일으킨다.만약 key를 참조하는 동안에만 entry가 살아있으면 되는 캐시라면 WeakHashMap을 사용하여 캐시를 생성하자. 다 쓴 entry는 그 즉시 자동으로 제거된다.하지만 대부분 캐시 엔트리의 유효 기간을 정확히 정의하기가 어렵다. 그래서 캐시에 넣은 시간이 길수록 엔트리의 가치를 떨어뜨리는 방식을 주로 사용한다.이런 방식에서는 ScheduledThreadPoolExcutor 같은 백그라운드 스레드를 사용하거나 부수 작업으로 엔트리를 청소해주어야 한다.마지막으로 listener와 callback 역시 메모리 누수가 일어나는 주범이다.클라이언트가 콜백을 등록만 하고 명확하게 해지하지 않는다면, 무언가 조치해주지 않는 이상 계속해서 쌓여간다. 이럴 때 콜백을 약한 참조(weak reference)로 저장하면 가비지 컬렉터가 직접 수거해갈 수 있다. 메모리 누수는 겉으로 잘 드러나지 않기 때문에 발견하기가 어렵다.철저한 코드 리뷰나 힙 프로파일러 같은 디버깅 도구를 동원해야만 발견하는 경우도 있다. 그렇기 때문에 예방법을 철저히 익혀두는 것이 가장 중요하다." }, { "title": "[Effective Java] Item 6", "url": "/posts/Effective-Java-Item-6/", "categories": "Study, Effective Java", "tags": "Java, Effective Java", "date": "2023-01-27 09:00:00 +0900", "snippet": "Effective Java - Item 6💡 불필요한 객체 생성을 피하라똑같은 기능의 객체를 여러 번 생성하는 것보다 재사용하는 것이 성능 향상에 도움이 될 수 있다. 특히 불변 객체는 언제든 재사용할 수 있다.String s1 = new String(”homework!”); // 하지 말아야 할 코드String s2 = \"homework!\";해당 코드의 s1, s2는 결과적으로 같은 기능을 한다.s1의 경우 “homework!” 자체가 해당 생성자로 만들어 내려는 String 인스턴스와 완전히 같지만, new String() 으로 감싸 실행될 때마다 String 인스턴스가 새로 생성된다.해당 코드가 빈번히 호출되는 메서드 안에 존재한다면 쓸데없는 String 인스턴스가 수백만 개씩 만들어질 수도 있다.반면 s2와 같은 경우에는 문자열 리터럴을 재사용하므로 같은 JVM에 동일한 문자열 리터럴이 존자한다면 재사용이 가능하다.정적 팩터리 메서드를 사용하는 경우에도 불필요한 객체 생성을 피할 수 있다.→ 항상 새로운 객체를 생성하는 Boolean(String) 생성자 대신 기존에 캐싱한 객체를 반환해주는Boolean.valueOf(String) 팩터리 메소드를 사용또한 데이터 베이스 커넥션과 같이 생성 비용이 비싼 객체가 반복해서 필요한 경우에는 캐싱을 통해 재사용 해야 한다. 다만 자신이 생성해야 하는 객체가 비싼 객체인지를 매번 명확하게 알수는 없다.예를 들어, 아래와 같이 String.matches() 메소드는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만, 성능이 중요한 상황에서 반복해 사용하기에는 적합하지 않다.static boolean isRomanNumeral(String s) {\treturn s.matches(\"^(?=.)M*(C[MD]|D?C{0,3})\"\t\t\t\t+ \"(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\");}→ matches() 메소드 내부에서 정의하는 Pattern 인스턴스는 매번 새로 생성되어 한 번 쓰고 버려져 곧바로 가비지 컬렉션의 대상이 된다.String 클래스의 matches() 메소드가 반환하는 Pattern은 불변 클래스(final class) 이고, 생성 비용이 비싸기 때문에 재사용하기를 권장한다. Pattern 은 입력받은 정규 표현식에 해당하는 유한 상태 머신(finite state machine)을 만들기 때문에 인스턴스 생성 비용이 높다.public class RomanNumerals {\tprivate static final Pattern ROMAN = Pattern.compile(\t\t\t\t\"^(?=.)M*(C[MD]|D?C{0,3})\"\t\t\t\t+ \"(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\");\tstatic boolean isRomanNumeral(String s) {\t\treturn ROMAN.matcher(s).matches();\t}}→ Pattern 인스턴스를 static final 필드로 꺼내고 이름을 지정하여 어떤 코드인지 명확하게 알 수 있다.성능을 개선하기 위해서는 필요한 정규표현식을 표현하는 Pattern 인스턴스를 클래스 초기화 과정에서 직접 생성하여 캐싱하고, 나중에 메서드가 호출될 때마다 해당 인스턴스를 재사용하도록 해야한다.다만, 개선된 isRomanNumeral 방식의 클래스가 초기화된 후 메서드를 한 번도 호출하지 않는다면 ROMAN 필드는 쓸데없이 초기화된 꼴이다. 메서드가 처음 호출될 때 필드를 초기화하는 지연 초기화(lazy initialzation)로 불필요한 초기화를 막을 수는 있지만, 코드가 복잡해지는 것에 비해 성능은 크게 개선되지 않을 때가 많다.또 다른 불필요한 객체를 만들어내는 예시로 오토박싱(auto boxing)을 들 수 있다.❓오토박싱(auto boxing) 자바 컴파일러가 primitive data type을 그에 상응하는 wrapper class로 자동 변환 시켜주는 것, 예를 들면 int를 Integer로, double을 Double로 변환한다.private static long sum() {\tLong sum = 0L;\tfor (long i = 0; i &lt;= Integer.MAX_VALUE; i++) \t\tsum += i;\treturn sum;}→ 모든 양의 정수의 총합을 구하는 메소드위 코드에서 sum을 Long으로 선언함에 따라 불필요한 Long 인스턴스가 계속해서 생성된다.단순히 sum의 타입을 long으로만 바꿔줘도 오토박싱이 일어나지 않고, 불필요한 인스턴스 생성이 줄어 성능이 좋아진다.의미상으로는 별다를 것이 없지만 성능에 있어서는 다르기 때문에 박싱된 기본 타입보다는 기본 타입을 사용하고 의도치 않은 오토박싱이 숨어들지 않도록 주의해야한다." }, { "title": "[Effective Java] Item 5", "url": "/posts/Effective-Java-Item-5/", "categories": "Study, Effective Java", "tags": "Java, Effective Java", "date": "2023-01-10 10:00:00 +0900", "snippet": "Effective Java - Item 5💡 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라많은 클래스가 하나 이상의 자원에 의존한다.이펙티브 자바에서는 맞춤법 검사기를 예시로 설명하고 있는데, 여기서 맞춤법 검사기(SpellChecker)는 사전(Dictionary)에 의존하고 있고, 정적 유틸리티 클래스나 싱글턴 패턴으로 구현되어 있다.public class SpellChecker {\tprivate static final Lexicon dictionary = new KoreanDictionary();\tprivate SpellChecker() {} //객체 생성 방지\tpublic static boolean isValid(String word) { ... }\tpublic static List&lt;String&gt; suggestions(String type) { ... }}→ 정적 유틸리티를 잘못 사용한 예 - 유연하지 않고 테스트가 어렵다.public class SpellChecker {\tprivate final Lexicon dictionary = new koreanDictionary();\tprivate SpellChecker(...) {}\tpublic static SpellChecker INSTANCE = new SpellChecker(...);\tpublic boolean isValid(String word) { ... }\tpublic List&lt;String&gt; suggestions(String type) { ... }}→ 싱글턴 패턴을 잘못 사용한 예 - 유연하지 않고 테스트하기 어렵다.두 방식은 모두 하나의 사전 만을 사용한다고 가정한다는 점에서 그리 적절하지 않다. 만약 다른 언어의 사전을 사용하고 싶은 경우에는 코드 자체를 변경 해야만 한다.SpellChecker가 여러 사전을 사용할 수 있도록 만들기 위해서는 간단하게 dictionary 필드에서 final을 제거하고 다른 사전으로 교체하는 메소드를 추가할 수도 있지만, 이 방식은 오류가 발생하기 쉽고 멀티 스레드 환경에서는 사용할 수 없다.이렇듯 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.대신 클래스가 여러 자원 인스턴스를 지원해야 하며 클라이언트가 원하는 자원을 사용해야 한다.이 조건을 만족하는 간단한 패턴이 있는데 바로 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식이다.의존 객체 주입의 한 형태로 맞춤법 검사기를 생성할 때, 의존 객체인 사전을 주입해주면 된다.public class SpellChecker {\tprivate final Lexicon dictionary;\tpublic SpellCheck(Lexicon dictionary) {\t\tthis.dictionary = Objects.reqquireNonNull(dictionary);\t}\tpublic boolean isValid(String word) { ... }\tpublic List&lt;String&gt; suggestions(String type) { ... }}→ 의존 객체 주입은 유연성과 테스트 용이성을 높여준다.의존 객체 주입 패턴은 매우 단순하여 많은 프로그래머들이 이 방식에 이름이 있다는 사실을 모른 채 사용해왔다.예시에서는 dictionary라는 하나의 자원만을 사용하지만, 자원이 몇 개든 의존 관계가 어떻든 상관없이 잘 작동된다. 또한 불변을 보장하여 같은 자원을 사용하려는 여러 클라이언트가 의존 객체들을 안심하고 공유할 수 있기도 하다.의존 객체 주입은 생성자, 정적 팩터리, 빌더 모두에 똑같이 응용할 수 있다.의존 객체 주입이 유연성과 테스트 용이성을 개선해주긴 하지만, 의존성이 수천 개나 되는 큰 프로젝트에서는 코드를 어지럽게 만들기도 한다.그래서 대거(Dagger), 주스(Guice), 스프링(Spring) 같은 의존 객체 주입 프레임워크를 사용하면 이런 어질러짐을 해소할 수 있다.이런 프레임워크들은 의존 객체를 직접 주입하도록 설계된 API를 알맞게 응용해 사용하고 있다." }, { "title": "[Effective Java] Item 4", "url": "/posts/Effective-Java-Item-4/", "categories": "Study, Effective Java", "tags": "Java, Effective Java", "date": "2023-01-06 10:00:00 +0900", "snippet": "Effective Java - Item 4💡 인스턴스화를 막으려거든 private 생성자를 사용하라❓인스턴스화란 메소드와 변수를 모아놓은 것에 불과한 클래스를 사용할 수 있도록 해당 클래스 타입의 객체명을 선언하고 값을 넣어 해당 클래스의 변수나 메소드를 사용 가능한 상태로 만드는 것기본 타입 값이나 배열 관련 메서드를 모아 놓을 때 java.lang.Math, java.util.Arrays특정 인터페이스를 구현하는 객체를 생성해주는 정적 메소드(혹은 팩토리)를 모아 놓을 때 java.util.Collectionsfinal 클래스를 상속해서 하위 클래스에 메서드를 넣는 것은 불가능 하기 때문에 final 클래스와 관련한 메소드를 모아 놓을 때위의 세가지 경우에 정적 필드와 정적 메소드만을 가진 클래스를 생성할 필요가 있다.생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어주기 때문에 원치않는 public 생성자가 만들어지고 사용자는 생성자가 사용하기 위해 만든 생성자인지 아닌지를 구분할 수가 없다.그렇다고 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다. 하위 클래스를 만들어 사용자가 상속하여 인스턴스화를 할 수 있기 때문이다.이런 경우에 생성자에 private 생성자를 추가한다.오직 명시된 생성자가 없을 경우에만 컴파일러가 기본 생성자를 만들기 때문에 클래스 바깥에서는 접근할 수 없는 private 생성자를 추가한다면 인스턴스화를 막을 수 있다. 코드public class UtilityClass { private UtilityClass() { \tthrow new AssertionError(); } ...}→ 무조건 Error를 던져줘야할 필요는 없으나 같은 클래스내에서 실수로라도 생성자를 호출할 수 없도록 해준다.이런 방식을 사용한다면 상속 역시 불가능하다.모든 생성자는 상위 클래스의 생성자를 호출하게 되어있는데 접근 권한을 private로 선언한다면 하위 클래스에서 상위 클래스의 생성자에 접근할 방법이 없기 때문이다." }, { "title": "[Effective Java] Item 3", "url": "/posts/Effective-Java-Item-3/", "categories": "Study, Effective Java", "tags": "Java, Effective Java", "date": "2023-01-04 10:00:00 +0900", "snippet": "Effective Java - Item 3💡 private 생성자나 열거 타입으로 싱글턴임을 보증하라❓ 싱글턴(singleton)객체의 유일성을 보장하기 위해서 인스턴스를 오직 하나만 생성할 수 있는 패턴을 의미한다.일반적으로 싱글턴 객체에 대한 참조를 public static 필드나 public static 메서드로 노출하기 때문에 어디에서나 싱글턴 객체 접근이 가능하다.싱글턴 패턴을 활용하면 객체를 재사용 할 수 있기 때문에 메모리 사용 낭비를 막을 수 있고 전역 객체이기 때문에 다른 객체와도 순조롭게 공유가 가능하다.보통 두 가지 방법을 사용하여 싱글턴을 생성한다.첫 번째는 public static 멤버를 final로 선언하여 생성하는 방법이다.또한 외부에서는 생성자를 통해 객체를 생성할 수 없도록 접근 권한을 private로 선언해야한다. public static final 필드 public class Singleton { \t \t \tpublic static final Singleton INSTANCE = new Singleton(); \t \t \tprivate Singleton() {} } → 클래스 생성시에 인스턴스를 딱 한 번 생성한다. 해당 방법은 클래스가 싱글턴임을 명확하게 알 수 있고 간결하게 표현할 수 있다는 장점을 가지고 있다. 다만, 리플렉션 API를 사용하여 예외적으로 강제로 생성자를 생성할 수 있는 방법이 존재하기 때문에 이를 주의하여 코드를 작성해야 한다. 👉 리플렉션 API를 사용하여 생성자를 호출할 경우 코드 import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; public class SingletonReflect { \tpublic static void main(String[] args) throws NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { \t\tConstructor&lt;Singleton&gt; declaredConstructor = Singleton.class.getDeclaredConstructor(); \t\tdeclaredConstructor.setAccessible(true); \t\t \t\tSingleton singleton = declaredConstructor.newInstance(); \t} } → setAccessible(boolean)메서드를 사용하여 Singleton 클래스의 private 생성자에 접근이 가능하다. public class Singleton { \t \tpublic static final Singleton INSTANCE = new Singleton(); \t \tprivate Singleton() { \t\tif(INSTANCE != null) { \t\t\tthrow new UnsupportedOperationException(\"생성자를 호출할 수 없습니다.\"); \t\t} \t} } → 예외를 사용하여 인스턴스가 존재할 경우 생성자 호출 불가하도록 막는다. 두 번째는 생성자는 private로 선언하고 정적 팩토리 메소드를 활용하는 방법이다. 코드public class Singleton {\t\tprivate static Singleton INSTANCE = new Singleton();\t\tprivate Singleton() {}\t\tpublic static Singleton getInstance() {\t\tif(INSTANCE == null) {\t\t\tINSTANCE = new Singleton();\t\t}\t\treturn INSTANCE;\t}}→ 클래스 생성시에 인스턴스를 딱 한번만 생성한다. getInstance() 메소드를 사용하는 경우에 이미 존재하는 인스턴스를 반환해주어 항상 같은 객체의 참조를 반환한다.정적 팩토리 메소드를 활용한다면 싱글턴이 아니도록 하고 싶을 때에도 API를 변경하지 않고도 쉽게 다른 객체를 반환하도록 변경할 수 있다. 또한 메소드 참조를 공급자로 사용할 수 있고(Singleton::getInstance), 정적 팩토리를 제네릭 싱글턴 팩토리로 만들 수 있다.❓제네릭 싱글턴 팩토리 제네릭으로 타입설정 가능한 인스턴스를 만들어두고, 반환 시에 제네릭으로 받은 타입을 이용해 타입을 결정하는 것이다.해당 방법도 역시 리플렉션 API를 사용하여 강제로 인스턴스를 생성할 수 있기 때문에 주의가 필요하다.public static 필드나 정적 팩토리 메소드를 활용하여 작성한 싱글턴 클래스를 직렬화하려면 단순히 Serializable을 구현하고 선언하는 것만으로는 부족하다. 모든 인스턴스 필드를 일시적(transient)이라고 선언하고 ReadResolve 메서드를 제공해야한다. 그렇지 않으면 역직렬화시 새로운 인스턴스가 생성되기 때문이다.마지막으로, Effective Java에서 싱글턴 패턴을 생성하는데 가장 이상적인 방법으로 알리고 있는 Enum을 활용하여 원소가 하나인 열거 타입을 선언하는 방법이 존재한다.public enum SingletonEnum {\tINSTANCE;}❓ Enum 클래스처럼 보이게 하는 상수이며, 서로 관련있는 상수들끼리 모아 상수들을 정의할 수 있다.해당 방법은 간결하게 작성할 수 있을뿐더러 어떠한 방식에서도 인스턴스가 추가로 생성되는 것을 막을 수 있다. 또 직렬화를 위해 추가적인 코드를 작성할 필요가 없기 때문에 싱글턴 객체를 생성할 때에는 Enum을 활용하는 방법을 가장 좋은 방법이라고 말할 수 있다." }, { "title": "[Effective Java] Item 2", "url": "/posts/Effective-Java-Item-2/", "categories": "Study, Effective Java", "tags": "Java, Effective Java", "date": "2022-12-30 10:00:00 +0900", "snippet": "Effective Java - Item 2💡 생성자에 매개변수가 많다면 빌더를 고려하라정적 팩토리와 생성자는 선택적 매개변수가 많을 때에는 대응하기 어렵다는 동일한 제약이 존재한다. 이런 문제의 해결책으로 세 가지 패턴을 들 수 있는데, 바로 점층적 생성자 패턴, 자바빈즈 패턴 그리고 빌더 패턴이다.❓ 점층적 생성자 패턴 (Telescoping Constructor Pattern)이란?필수 매개변수만 받는 생성자, 필수 매개변수와 선택 매개변수 1개를 받는 생성자, 선택 매개변수를 2개 받는 생성자 형태로 선택 매개변수를 전부 다 받는 생성자까지 늘려가는 방식이다. 코드 public class NutritionFacts { \tprivate final int servingSize; //필수 \tprivate final int servings; //필수 \tprivate final int calories; //선택 \tprivate final int fat; //선택 \tprivate final int sodium; //선택 \tprivate final int carbohydrate; //선택 \t \tpublic NutritionFacts(int servingSize, int servings, int calories) { \t\tthis(servingSize, servings, calories, 0); \t} \t \tpublic NutritionFacts(int servingSize, int servings, int calories, int fat) { \t\tthis(servingSize, servings, calories, fat, 0); \t} \tpublic NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) { \t\tthis(servingSize, servings, calories, fat, sodium, 0); \t} \t \tpublic NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate) { \t\tthis.servingSize = servingSize; \t\tthis.servings = servings; \t\tthis.calories = calories; \t\tthis.fat = fat; \t\tthis.sodium = sodium; \t\tthis.carbohydrate = carbohydrate; \t} } → 해당 클래스에서 필수 매개변수는 2개뿐이지만, 이외의 선택 매개변수들도 어쩔 수 없이 값을 지정 해줘야 하기 때문에 효율이 떨어진다. 하지만 매개변수 개수가 많아지면 많아질수록 많은 조합이 만들어지고, 생성자의 수가 많아져 클라이언트 코드 작성 효율과 가독성이 떨어진다.또한 인자로 받는 매개변수 타입이 같은 경우에는 생성자를 만들 수 없을 뿐더러 생성자를 호출하는 입장에서는 해당 매개변수와 개수가 맞는지 항상 확인 해야한다는 불편함이 따른다.❓ 자바빈즈 패턴 (JavaBeans Pattern)이란?매개변수가 없는 생성자로 객체를 만든 후, 세터(setter) 메서드들을 호출해 원하는 매개변수의 값을 설정하는 방식이다. 코드는 길어지지만 점층적 생성자 패턴에 비해 인스턴스를 만들기 쉽고 가독성 또한 좋다. 코드 public class NutritionFacts { \tprivate int servingSize = -1; \tprivate int servings = -1; \tprivate int calories = 0; \tprivate int fat = 0; \tprivate int sodium = 0; \tprivate int carbohydrate = 0; \t \tpublic NutritionFacts() {} \t \tpublic void setServingSize(int val) { servingSize = val; } \tpublic void setServings(int val) { servings = val; } \tpublic void setCalories(int val) { calories = val; } \tpublic void setFat(int val) { fat = val; } \tpublic void setSodium(int val) { sodium = val; } \tpublic void setCarbohydrate(int val) { carbohydrate = val; } } → 해당 클래스에서 필수 매개변수는 2개뿐이지만, 이외의 선택 매개변수들도 어쩔 수 없이 값을 지정 해줘야 하기 때문에 효율이 떨어진다. 그러나 객체 하나를 생성하려면 메서드를 여러 개 호출해야 한다는 단점도 존재한다. 또한 한 번의 생성자 호출만으로 생성이 완료되지 않기 때문에 일관성(consistency)이 무너지고 변하지 않는 불변(immutable) 객체를 만들 수 없다.마지막으로, 점층적 생성자 패턴의 안전성과 자바빈즈 패턴의 가독성을 결합한 디자인 패턴인 빌더 패턴이 존재한다.❓ 빌더 패턴 (Builder Pattern)이란?필수 매개변수만으로 정적 팩토리 메서드를 이용해 빌더 객체를 얻은 뒤, 빌더 객체가 제공하는 세터 메서드들로 필요한 선택 매개변수를 입력할 수 있다.각각의 세터 메서드는 값을 설정한 뒤 자기 자신(Builder)을 반환하기 때문에 연속해서 메서드 호출이 가능하고, 마지막으로 build() 메서드를 사용해 필요한 객체를 완성하여 반환할 수 있다. 코드 package effectiveJava.item02; public class NutritionFacts3 { \tprivate final int servingSize; \tprivate final int servings; \tprivate final int calories; \tprivate final int fat; \tprivate final int sodium; \tprivate final int carbohydrate; \t \tpublic static class Builder { \t\tprivate final int servingSize; \t\tprivate final int servings; \t\t \t\tprivate int calories = 0; \t\tprivate int fat = 0; \t\tprivate int sodium = 0; \t\tprivate int carbohydrate = 0; \t\t \t\tpublic Builder(int servingSize, int servings) { \t\t\tthis.servingSize = servingSize; \t\t\tthis.servings = servings; \t\t} \t\t \t\tpublic Builder calories(int val) { \t\t\tcalories = val; \t\t\treturn this; \t\t} \t\t \t\tpublic Builder fat(int val) { \t\t\tfat = val; \t\t\treturn this; \t\t} \t\t \t\tpublic Builder sodium(int val) { \t\t\tsodium = val; \t\t\treturn this; \t\t} \t\t \t\tpublic Builder carbohydrate(int val) { \t\t\tcarbohydrate = val; \t\t\treturn this; \t\t} \t\t \t\tpublic NutritionFacts3 build() { \t\t\treturn new NutritionFacts3(this); \t\t} \t} \t \tprivate NutritionFacts3(Builder builder) { \t\tservingSize = builder.servingSize; \t\tservings = builder.servings; \t\tcalories = builder.calories; \t\tfat = builder.fat; \t\tsodium = builder.sodium; \t\tcarbohydrate = builder.carbohydrate; \t} } → 점층적 생성자 패턴에 비해 필요한 인스턴스들만 생성하기 쉽다. 👉 계층적으로 설계된 클래스에 빌더 패턴 사용 예제 코드 package effectiveJava.item02; import java.util.Objects; import java.util.EnumSet; import java.util.Set; public abstract class Pizza { public enum Topping {HAM, MUSHROOM, ONION, PEPPER, SAUSAGE} final Set&lt;Topping&gt; toppings; abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; { EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class); public T addTopping(Topping topping) { toppings.add(Objects.requireNonNull(topping)); return self(); } abstract Pizza build(); // 하위 클래스는 이 메서드를 오버라이딩하여 \"this\"를 반환해야한다. protected abstract T self(); } Pizza(Builder&lt;?&gt; builder) { toppings = builder.toppings.clone(); } } → 추상 메서드 self() 는 하위 클래스에서 형변환을 하지 않고도 자기 자신을 리턴하여 메서드를 연쇄적으로 호출할 수 있도록 한다. package effectiveJava.item02; public class NyPizza extends Pizza { public enum Size {SMALL, MEDIUM, LARGE} private final Size size; public static class Builder extends Pizza.Builder&lt;Builder&gt; { private final Size size; public Builder(Size size) { this.size = size; } @Override NyPizza build() { return new NyPizza(this); } @Override protected Builder self() { return this; } } private NyPizza(Builder builder) { super(builder); size = builder.size; } } → Pizza 의 하위 클래스, 크기(size)를 필수 매개변수로 받는다. package effectiveJava.item02; public class Calzone extends Pizza { private final boolean sauceInside; public static class Builder extends Pizza.Builder&lt;Builder&gt; { private boolean sauceInside = false; public Builder sauceInside() { this.sauceInside = true; return this; } @Override Calzone build() { return new Calzone(this); } @Override protected Builder self() { return this; } } private Calzone(Builder builder) { super(builder); sauceInside = builder.sauceInside; } } → Pizza 의 하위 클래스, 소스 선택(sauceInside)를 필수 매개변수로 받는다. NyPizza pizza = new NyPizza.Builder(SMALL) .addTopping(ONION).build(); Calzone calzone = new Calzone.Builder().sauceInside() .addTopping(HAM).build(); → NyPizza와 Calzone 객체 생성 위의 코드에서 NyPizza.Builder는 NyPizza를 반환하고 Calzone.Builder는 Calzone를 반환한다. 이처럼 하위 클래스의 메소드가 상위 클래스의 메소드에서 정의한 반환 타입이 아닌, 그 하위 타입을 반환하는 기능을 공변 반환 타이핑(convariant return typing)이라고 한다.&lt;JDK 1.5 이상&gt; 해당 기능 덕분에 클라이언트는 형변환에 신경 쓰지 않고 빌더를 사용할 수 있다. 물론 빌더 패턴도 단점이 없는 것은 아니다. 객체를 생성하기 위해서는 먼저 빌더 클래스부터 정의해야 한다. 빌더의 생성 비용이 큰 것은 아니지만, 성능에 민감한 상황에서는 문제가 될 수 있다.또한 매개변수가 몇 개 없고, 변경될 가능성이 아예 없다면 코드가 다소 장황한 빌드 패턴보다는 점층적 생성자 패턴을 사용하는 것이 더 유리하다.그리고 추가로 빌더 패턴을 작성하는 쉽고 편리한 방법이 존재하는데 바로 Lombok 라이브러리의 @Builder 어노테이션이다. @Builder 어노테이션은 모든 멤버 필드에 대해서 매개변수를 받는 기본 생성자를 만들어주기 때문에 따로 Builder Class를 작성할 필요가 없어 코드 작성에 매우 용이하다.다만 접근 레벨이 default이기 때문에, 동일 패키지 내에서 해당 생성자를 호출 할 수 있는 문제가 생긴다. 그러므로 객체 생성 시 받아야 하는 매개변수들만 존재하는 생성자를 만들고 그 생성자에 @Builder 를 지정하는 것이 바람직하다." }, { "title": "[Effective Java] Item 1", "url": "/posts/Effective-Java-Item-1/", "categories": "Study, Effective Java", "tags": "Java, Effective Java", "date": "2022-12-29 10:00:00 +0900", "snippet": "Effective Java - Item 1💡 생성자 대신 정적 팩토리 메서드를 고려하라❓ 정적 팩토리 메서드(Static Factory Method)란?오직 클래스의 인스턴스만을 반환하기 위해 정의된 정적 메소드를 정적 팩토리 메소드라고 한다. 코드 public final class LocalTime \t\t\timplements Temporal, TemporalAdjuster, Comparable&lt;LocalTime&gt;, Serializable { \t \t... \t\tpublic static LocalTime of(int hour, int minute, int second) { \t\t HOUR_OF_DAY.checkValidValue(hour); \t\t if ((minute | second) == 0) { \t\t return HOURS[hour]; // for performance \t\t } \t\t MINUTE_OF_HOUR.checkValidValue(minute); \t\t SECOND_OF_MINUTE.checkValidValue(second); \t\t return new LocalTime(hour, minute, second, 0); \t\t} \t... \t\tprivate LocalTime(int hour, int minute, int second, int nanoOfSecond) { \t\t this.hour = (byte) hour; \t\t this.minute = (byte) minute; \t\t this.second = (byte) second; \t\t this.nano = nanoOfSecond; \t\t} \t... } 그렇다면 왜 생성자를 호출하지 않고 정적 팩토리 메소드를 사용하는지, 정적 팩토리 메소드의 장/단점을 정리해보자.장점 첫 번째, 이름을 가질 수 있다. 객체를 생성자로 호출할 때에는 클래스의 매개변수가 많을 수록, 같은 타입의 매개변수가 여러 개 존재할수록, 개발자들은 각 생성자들이 어떤 의미인지 쉽게 파악할 수 없다. 또한, public 생성자는 하나의 시그니처로 하나만 생성할 수 있다. 예를 들어, 학교를 의미하는 클래스에 학생과 선생님이 존재한다. 이때 학생의 이름인 String 변수를 받는 생성자가 존재한다면 선생님의 이름인 String 변수를 받는 생성자는 오류가 발생한다. 이미 하나의 String 변수를 받는 생성자가 존재하기 때문에 다른 생성자가 호출될 수 있기 때문이다.반면 정적 팩토리 메서드에서는 메서드명을 지정할 수 있기 때문에 한 클래스에 시그니처가 같은 생성자가 여러 개 존재하는 경우에는 생성자를 정적 팩토리 메서드로 바꾸고 메소드명으로 각각의 특성을 나타내어 사용할 수 있다. 코드 public class School { \tString studentName; \tString teacherName; \tint grade; \tpublic School(String studentName) { \t\tthis.studentName = studentName; \t} // 에러 \tpublic School(String teacherName) { \t\tthis.teacherName= teacherName; \t} \tpublic static School createStudent(String name, int grade) { \t\treturn new School(name, grede); \t} \tpublic static School createTeacher(String name, int grade) { \t\treturn new School(name, grede); \t} public static void main(String[] args) { \t\tSchool student = createStudent(\"학생\", 3); \t\tSchool teacher = createTeacher(\"선생님\", 1); \t} } → 매개변수의 종류와 개수가 같지만 메소드명으로 인해 반환되는 인스턴스의 명확한 구분이 가능하다. 두 번째, 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다. 주로 사용되는 불변 객체가 존재한다면 미리 생성된 인스턴스를 캐싱하여 재활용함으로써 불필요하게 객체를 생성할 필요가 없다.대표적으로 Boolean.valueOf(boolean) 메소드가 있다. Boolean 클래스에서는 TURE, FALSE를 상수로 정의해 놓고 valueOf() 메소드가 호출 되었을 때 객체를 새로 생성하지 않고 존재하는 상수를 반환해준다. 코드 public final class Boolean implements java.io.Serializable, Comparable&lt;Boolean&gt; { public static final Boolean TRUE = new Boolean(true); public static final Boolean FALSE = new Boolean(false); \t... \t\tpublic static Boolean valueOf(boolean b) { return (b ? TRUE : FALSE); } \t... } → valueOf(b) 메소드를 호출하면 이미 생성되어 있는 객체를 반환한다. 세 번째, 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다. 하위 클래스들이 하나의 상위 클래스를 상속 받는 구조인 경우에 상위 클래스에서는 어떠한 조건에 따라 하위 클래스 객체들을 반환할 수 있다. 이때, 하위 클래스의 구현체를 공개하지 않고도 반환이 가능하기 때문에 API를 작게 유지할 수 있다.대표적으로, java.util.Collections 클래스에서는 수정 불가나 동기화 등의 기능을 포함하여 총 45개의 유틸리티 구현체를 제공하는데 대부분 정적 팩토리 메소드를 통하여 얻을 수 있다. 코드 public class Arrays { \t... \t\tpublic static &lt;T&gt; List&lt;T&gt; asList(T... a) { return new ArrayList&lt;&gt;(a); } \t... } → java.util.Arrays 클래스에서 asList() 메소드를 통해 List의 하위 클래스인 ArrayList를 반환한다. 네 번째, 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. 단순히 하위 클래스만을 반환하는 것이 아니라 매개변수에 따라서 각각 다른 하위 클래스의 객체를 반환하는 것이 가능하다. 이때, 클라이언트는 어떤 객체가 반환 되는 지에 대해서는 알 필요가 없다.예를 들어 EnumSet 클래스의 noneOf()메소드는 universe 값에 따라서 다른 하위 클래스를 반환해준다. 코드 public abstract class EnumSet&lt;E extends Enum&lt;E&gt;&gt; extends AbstractSet&lt;E&gt; implements Cloneable, java.io.Serializable { \t\tpublic static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) { Enum&lt;?&gt;[] universe = getUniverse(elementType); if (universe == null) throw new ClassCastException(elementType + \" not an enum\"); if (universe.length &lt;= 64) return new RegularEnumSet&lt;&gt;(elementType, universe); else return new JumboEnumSet&lt;&gt;(elementType, universe); } } → EnumSet 클래스의 noneOf() 메소드는 universe의 length 값이 64개 이하일 경우 RegularEnumSet, 아닐 경우에는 JumboEnumSet 객체를 반환해준다. 다섯 번째, 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스는 존재하지 않아도 된다. 지금까지는 이미 구현되어 있는 구현체가 기준이 되었지만, 정적 팩토리 메소드를 활용했을 때에 구현되어있지 않은 객체의 클래스가 존재하지 않아도 된다.이러한 특징은 서비스 제공자 프레임워크(Service Provider Framework) 의 근간이 된다. 서비스를 제공하는 제공자는 서비스의 구현체이고, 이 구현체들을 클라이언트에 제공하는 역할을 프레임워크가 통제하여 클라이언트를 구현체로부터 분리해준다.서비스 제공자 프레임워크는 3개의 핵심 컴포넌트로 이루어져 있다. 서비스 인터페이스 (service interface) : 구현체의 동작을 정의하는 인터페이스 제공자 등록 API (provider registration API) : 제공자가 구현체를 등록하는 API 서비스 접근 API (service access API) : 클라이언트가 서비스의 인스턴스를 얻을 때 사용하는 API이 밖에 종종 네 번째 컴포넌트인 서비스 제공자 인터페이스 (service provider interface) 가 쓰인다.해당 인터페이스가 없다면 각 구현체를 인스턴스로 만들 때 리플렉션을 사용해야 한다.대표적인 서비스 제공자 프레임워크로는 JDBC(Java Database Connectivity)가 존재한다. JDBC : java에서 데이터베이스에 접속할 수 있도록 하는 java API — Connection : 서비스 인터페이스 — DriverManager.registerDriver : 제공자 등록 API — DriverManager.getConnection : 서비스 등록 API — Driver : 서비스 제공자 인터페이스 단점 첫 번째, 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다. 예를 들어 java.util.Collections 클래스의 경우에는 모든 생성자가 private로 선언되어 있기 때문에 java.util.Collections로 만든 구현체는 상속이 불가능하다.다만 이러한 점은 상속보다 컴포지션을 사용하도록 유도하고 불변 타입으로 만들기 위해 제약을 지켜야 한다는 점에서 오히려 장점이 될 수 있다. 두 번째, 정적 팩토리 메소드는 프로그래머가 찾기 어렵다. public 생성자는 API 설명에서 확인할 수 있기 때문에 프로그래머들이 알기 쉽지만, 정적 팩토리 메소드같은 경우에는 javadoc에서도 따로 정리하지 않기 때문에 API 문서를 잘 작성하고 메소드명을 알려진 규약에 따라 지어 프로그래머가 알기 쉽게 해주어야 한다. from : 매개변수를 하나를 받아 해당 타입의 인스턴스를 반환하는 형변환 메서드 → Date d = Date.from(instant); of : 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드 → Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING); valueOf : from과 of의 더 자세한 버전 → BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE); instance / getInstance : (매개변수를 받는다면) 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다. → StackWalker luke = StackWalker.getInstance(options); create / newInstance : instance 혹은 getInstance와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장한다. → Object newArray = Array.newInstance(classObject, arrayLen); getType : getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩토리 메서드를 정의할 때 쓴다. “Type”은 팩토리 메소드가 반환할 객체의 타입이다. → FileStore fs = Files.getFileStore(path); newType : newInstance와 같으나 생성할 클래스가 아닌 다른 클래스에 팩토리 메서드를 정의할 때 쓴다. “Type”은 팩토리 메소드가 반환할 객체의 타입이다. → BufferedReader br = Files.newBufferedReader(path); type : getType과 newType의 간결한 버전 → List&lt;Complaint&gt; litany = Collections.list(legacyLitany); " }, { "title": "[Java] Comparable 과 Comparator", "url": "/posts/Java-Comparable-%EA%B3%BC-Comparator/", "categories": "Programming, Java", "tags": "Java", "date": "2022-12-26 10:00:00 +0900", "snippet": "Comparable 과 Comparator💡 Java에서 객체를 정렬할 수 있는 인터페이스(interface)에 대해 학습해보자Comparable java.lang 패키지에 속해있으며, Comparable 인터페이스를 사용하기 위해서는 반드시 선언되어 있는 compareTo(T o) 메소드를 재정의(Override) 해야한다. — Comparable 인터페이스는 compareTo() 메소드를 이용해 자기 자신과 매개 변수인 객체를 비교할 수 있다. compareTo(T o) 구현public class Test {\tpublic static void main(String[] args) {\t\tPerson a = new Person(\"AAA\", 27);\t\tPerson b = new Person(\"BBB\", 31);\t\tint isCompare = a.compareTo(b);\t\tif(isCompare &gt; 0) {\t\t\tSystem.out.println(\"AAA가 BBB보다 나이가 많다.\");\t\t} else if(isCompare == 0){\t\t\tSystem.out.println(\"AAA와 BBB는 나이가 같다.\");\t\t} else {\t\t\tSystem.out.println(\"AAA가 BBB보다 나이가 적다.\");\t\t}\t}}class Person implements Comparable&lt;Person&gt;{ String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public int compareTo(Person o) { return this.age - o.age; }}Comparator java.util 패키지에 속해 있으며 해당 인터페이스는 @FunctionalInterface , 즉 함수형 인터페이스이다. Comparator 인터페이스를 사용하기 위해서는 반드시 선언되어 있는 compare(T o1, T o2) 메소드를 재정의(Override) 해야한다. — Comparator 인터페이스는 compareTo() 메소드를 이용해 두 매개변수 객체를 비교할 수 있다. 구현 import java.util.Comparator;public class Test {\tpublic static void main(String[] args) {\t\tPerson a = new Person(\"AAA\", 27);\t\tPerson b = new Person(\"BBB\", 31);\t\tint isCompare = a.compare(a, b);\t\tint isCompare2 = b.compare(a, b);\t\tif(isCompare &gt; 0) {\t\t\tSystem.out.println(\"AAA가 BBB보다 나이가 많다.\");\t\t} else if(isCompare == 0){\t\t\tSystem.out.println(\"AAA와 BBB는 나이가 같다.\");\t\t} else {\t\t\tSystem.out.println(\"AAA가 BBB보다 나이가 적다.\");\t\t}\t\tif(isCompare2 &gt; 0) {\t\t\tSystem.out.println(\"AAA가 BBB보다 나이가 많다.\");\t\t} else if(isCompare2 == 0){\t\t\tSystem.out.println(\"AAA와 BBB는 나이가 같다.\");\t\t} else {\t\t\tSystem.out.println(\"AAA가 BBB보다 나이가 적다.\");\t\t}\t}}class Person implements Comparator&lt;Person&gt;{\tString name;\tint age;\tpublic Person(String name, int age) {\t\tthis.name = name;\t\tthis.age = age;\t}\t@Override\tpublic int compare(Person o1, Person o2) {\t\treturn o1.age - o2.age;\t}}comparator 활용 comparator 인터페이스의 compare() 메소드는 두 개의 매개 변수를 받아 호출된다. 그렇기 때문에 익명를 생성하여 구현한다면 더욱 효율적으로 사용이 가능하다. 구현 import java.util.Comparator;public class Test {\tpublic static void main(String[] args) {\t\tPerson a = new Person(\"AAA\", 27);\t\tPerson b = new Person(\"BBB\", 31);\t\tComparator&lt;Person&gt; c = new Comparator&lt;Person&gt;() {\t\t\t@Override\t\t\tpublic int compare(Person o1, Person o2) {\t\t\t\treturn o1.age - o2.age;\t\t\t}\t\t};\t\tint isCompare = c.compare(a, b);\t\tif(isCompare &gt; 0) {\t\t\tSystem.out.println(\"AAA가 BBB보다 나이가 많다.\");\t\t} else if(isCompare == 0){\t\t\tSystem.out.println(\"AAA와 BBB는 나이가 같다.\");\t\t} else {\t\t\tSystem.out.println(\"AAA가 BBB보다 나이가 적다.\");\t\t}\t}}class Person {\tString name;\tint age;\tpublic Person(String name, int age) {\t\tthis.name = name;\t\tthis.age = age;\t}}" }, { "title": "[OS] 병행 프로세스(2)", "url": "/posts/OS-%EB%B3%91%ED%96%89-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4(2)/", "categories": "Computer Science, OS", "tags": "OS", "date": "2022-03-24 10:00:00 +0900", "snippet": "병행 프로세스프로세스의 상호협력공통 작업을 수행하기 위해 서로 협동하는 경우 생산자/소비자 문제, 판독기/기록기 문제생산자/소비자 문제 유한 버퍼 문제 생산자 : 버퍼에 데이터를 채우는 프로세스 소비자 : 버퍼에 있는 데이터를 읽어내는 프로세스 생산자 프로세스repeatP(empty);P(mutex);V(mutex);V(full);until false; 소비자 프로세스repeatP(full);P(mutex);V(mutex);V(empty);until false;판독기/기록기 문제 여러 개의 판독기가 동시에 공유 데이터 객체에 접근하는 것은 문제 없음 기록기와 또 다른 프로세스(판독기 또는 기록기)가 동시에 공유 객체에 접근한다면 문제가 발생, 기록기가 공유 객체에 대해 배타적 접근을 하도록 해야한다. 우선순위에 따른 문제의 변형 제1판독기/기록기 문제(판독기 우선) 기록기가 이미 공유객체의 사용을 허가 받은 것이 아니라면 판독기는 대기하지 않음 기록기의 기아상태 유발 가능 제2판독기/기록기 문제(기록기 우선) 일단 기록기가 준비되었다면 기록을 가능한 한 빨리 수행할 수 있도록 함 판독기의 기아상태 유발 가능 판독기 프로세스var mutex, wrt : semaphore;readcount : integer;P(mutex); readcount := readcount + 1; if readcount = 1 then P(wrt);V(mutex);//..읽기 수행..P(mutex); readcount := readcount - 1; if readcount = 0 then V(wrt);V(mutex); 기록기 프로세스 P(wrt);//..쓰기 수행..V(wrt); 프로세스 간의 통신병행 프로세스 사이의 통신을 위한 방법 공유기억장치 기법 프로세스 간에 공유변수를 이용하여 정보를 교환하도록 하는 것 예 : 유한 버퍼 고속 통신 가능 통신기능 제공의 책임 : 응용 프로그래머 메시지 시스템 기법 메세지 교환방식을 이용함으로써 프로세스가 공유변수에 의존하지 않고도 서로 통신할 수 있게 하는 것 send/receive 연산자 소량의 데이터 교환에 유용 통신기능 제공의 책임 : 운영체제 통신 링크 : 프로세스들 사이에 메시지를 주고받기 위한 연결통로 논리적 구현에 대한 이슈 어떻게 링크를 설정하는가? 한 링크가 2개 이상의 프로세스와 연결될 수 있는가? 통신 프로세스의 pair에 얼마나 많은 링크가 있는가? 링크의 용량은 얼마인가? 즉, 링크가 어느 정도 버퍼 공간을 갖는가? 갖는다면 어느 정도인가? 메시지의 크기는 어느 정도인가? 링크가 가변크기 또는 고정크기 메시지를 수용할 수 있는가? &lt;/div&gt;&lt;/details&gt; 직접 통신 메시지 전달 연산에 수신자나 송신자 이름을 명시 통신 링크는 자동 설정됨 하나의 링크는 두 프로세스 사이만 연관되며 각 통신 프로세스 쌍 사이에는 정확히 하나의 링크가 존재한다. 링크는 양방향이다. 간접 통신 메시지 전달 연산에 우편함 이름을 명시 공유 우편함이 있는 경우에만 설정됨 한 링크는 2개 이상의 프로세스들과 연관될 수 있으며 각 통신 프로세스 쌍 사이에는 여러 링크가 존재 가능 링크는 단방향 또는 양방향이다. 링크의 용량 ‘0’ 용량 - 큐의 최대 길이가 0이다. 제한된 용량 - 큐는 유한 길이 n을 갖는다. 무제한 용량 - 큐는 무한한 길이를 가지고 있다. 예외조건 프로세스가 종료된 경우 송신 프로세스가 종료된 경우 수신 프로세스가 종료된 경우 메시지를 상실한 경우 운영체제가 이런 사건을 탐지하고 메시지를 재전송한다. 송신 프로세스가 이런 사건을 탐지하고, 원한다면 메시지를 재전송한다. 운영체제가 탐지 후 송신 프로세스에게 통지한다. 송신 프로세스는 원한다면 계속 수행할 수 있다. 메시지가 혼합된 경우 운영체제가 처음의 메시지를 재전송하거나 이런 사건을 프로세스에 통보한다. " }, { "title": "[OS] 상호 배제 알고리즘", "url": "/posts/OS-%EC%83%81%ED%98%B8-%EB%B0%B0%EC%A0%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/", "categories": "Computer Science, OS", "tags": "OS", "date": "2022-03-23 10:00:00 +0900", "snippet": "상호 배제 알고리즘SW solutions Dekker’s algorithm 두 개의 프로세스 간 상호 배제를 보장하는 최초의 알고리즘 Flag : 임계 구역에 들어가있는지 여부를 알려주는 변수 Turn : 어느 프로세스가 임계 영역에 들어가겠다고 요구할 권한이 있는지 알려주는 변수 while(1) { // 프로세스i의 진입 영역 flag[i] = ture; // 프로세스i가 임계구역에 진입하기 위해 진입을 알림 while(flag[j]) { // 프로세스j가 임계구역에 진입하려고 하는지 확인 if (turn == j) { // 프로세스j가 임계구역에 있다면 flag[i] = flase; // 프로세스i가 진입을 취소하고 while (turn == j); // 프로세스i의 차례가 올 때까지 대기 함. flag[i] =ture; // 차례가 넘어왔다면 진입을 알림. } } // Critical Section turn = j; // 임계구역의 사용이 끝났다면 차례를 프로세스j에게 넘김. flag[i] = false; // 진입을 취소하여 임계구역 사용완료를 알림.} Peterson’s algorithm 프로세스가 두 개일 때 상호 배제를 보장하는 알고리즘 while(1) { // 프로세스i의 진입 영역 flag[i] = ture; // 프로세스i가 임계구역에 진입하기 위해 진입을 알림. turn = j; // 프로세스j에게 진입을 양보함. // (두 프로세스중 먼저 양보한쪽이 먼저 임계구역에 들어가게 됨.) while (flag[j] &amp;&amp; turn = j); // 프로세스i의 차례가 될 때까지 대기를 함.// critical section flag[i] = false // 임계구역 사용완료를 알림.} Dijkstra’s algorithm 프로세스 n개의 상호배제 문제를 해결한 최초의 알고리즘 flag[i] 변수 상태 idle : 프로세스가 임계 구역에 진입 시도를 하고 있지 않은 상태 want-in : 프로세스의 임계구역 진입 시도 1단계 in-CS : 프로세스의 임계구역 진입 시도 2단계 및 임계구역 내에 있을 때 while(1) { // 프로세스i의 진입 영역\tdo {\t// 임계구역 진입시도 1단계\t flag[i] = want-in // 1단계 진입시도를 한다고 알림\t while (turn != i ) { // 자신의 차례가 될 때까지 대기를 함.\t if (flag[turn] == idle) { // 임계구역에 프로세스가 없다면,\t turn = i; // 자신의 차례로 변경함.\t }\t }\t// 임계구역 진입시도 2단계\t flag[i] = in-CS // 임계구역에 진입하겠다고 알림.\t j = 0;\t while ((j &lt; n) &amp;&amp; (j == i|| flag[j] != in-CS ){ // 자신을 제외한 in-CS 상태의 프로세스가 있는지 검사 함.\t j = j + 1;\t }\t} while(j &lt; n) // 자신 외에 2단계 진입을 시도하는 프로세스가 있다면 다시 1단계로 돌아감.\t// critical section // in-CS 상태의 프로세스가 자신밖에 없다면 임계영역에 진입함.\tflag[i] = idle; // 임계구역 사용완료를 알림.} Knuth’s algorithm 이전 알고리즘 관계 분석 후 일치하는 패턴을 찾아 패턴의 반복을 줄여 프로세스에 프로세서 할당 무한정 연기할 가능성을 배제하는 해결책을 제시했으나, 프로세스들이 오래 기다려야 한다. Eisenberg and McGuire’s algorithm Lamport’salgorithm 프로세스 n개의 상호 배제 문제를 해결한 알고리즘 프로세스에게 고유한 번호를 부여하고, 번호를 기준으로 우선순위를 정하여 우선순위가 높은 프로세스(번호가 낮은 프로세스)가 먼저 임계 구역에 진입하도록 구현되었습니다. while(1) { // 프로세스i의 진입 영역 choosing[i] = ture; // 번호표 받을 준비 number[i] = max(number[0], number[1], ..., number[n-1]) + 1; // 번호표 부여 // (번호표 부여중 선점이 되어 같은 번호를 부여 받는 프로세스가 발생할 수 있음) chossing[i] = false; // 번호표를 받음 for (j = 0; j &lt; n; j++) { // 모드 프로세스와 번호표를 비교함. while (choosing[j]); // 프로세스j가 번호표를 받을 때까지 대기 while ((number[j] != 0) &amp;&amp; ((number[j] &lt; number[i]) // 프로세스 j가 프로세스 i보다 번호표가 작거나(우선순위가 높고) || (number[j] == number[i] &amp;&amp; j &lt; i)); // 또는 번호표가 같을 경우 j 가 i 보다 작다면 // 프로세스 j가 임계구역에서 나올 때까지 대기. }// Critical Section number[i] = 0; // 임계구역 사용완료를 알림.}소프트웨어 솔루션의 문제점 속도가 느리고 구현이 복잡하다. 수행 도중 preemption이 발생할 수 있으며, 운영체제가 이런 인터럽트를 막아준다고 하더라도 오버헤드가 발생한다. busy waiting이 발생하여 비효율적이다.HW solution TestAndSet(TAS) instruction Test와 Set을 한번에 수행하는 기계어 TAS를 이용한 상호배제 구현 boolean TestAndSet(boolean &amp;target) { boolean rv = target; target = true; return rv;}// lock의 초기값은 false, 처음 실행한 프로세스는 첫 반복문 (while)을 통과do { while(TestAndSet(lock)); // lock을 걸어줌, lock이 풀릴떄까지 다른 프로세스는 CS에 접근 불가 // critical section lock = false; // remainder section} N개의 프로세스에서 상호배제 구현boolean lock = false;do { waiting[i] = true; // 프로세스 i를 대기열에 넣음. key = true; while (waiting[i] &amp;&amp; key) // 대기가 풀리거나 lock이 풀릴 때까지 대기함 key = TestAndSet(&amp;lock); // lock 값을 key에 반환 waiting[i] = false; // CS에 접근할 수 있으므로 대기를 풀어줌. // Critical Section j = (i + 1) % n; while((j != i) &amp;&amp; !waiting[j]) // 대기 중인 프로세스를 찾음 j = (j + 1) % n; if(j == i) // 대기 중인 프로세스가 없으면 lock = false; // 다른 프로세스의 진입을 허용할 수 있게 lock을 풀어줌. else // 대기 프로세스가 있으면 다음 순서로 임계 영역에 진입하게 함. waiting[j] = false; // 임계 영역에 진입할 수 있도록 대기를 품.} while (true);하드웨어 솔루션의 문제점 하드웨어가 한번에 수행되는 것을 보장해 주기 때문에 소프트웨어 솔루션에 비해 구현이 간단하지만 Busy waiting 문제가 있어 비효율적이다.OS supported SW solution Spinlock 임계 구역에 진입이 불가능할 때 진입이 가능할 때까지 루프르르 돌면서 재시도하는 방식으로 구현된 락을 가리킨다. 운영체제의 스케줄링 지원을 받지 않기 때문에, 해당 스레드에 대한 문맥 교환이 일어나지 않는다. 멀티 프로세서 시스템에서만 사용할 수 있다. // 자원이 없다면 while 루프를 돌면서 기다리는 방식(busy-waiting)wait(S) { while (S &lt;= 0); // 자원이 없다면 while 루프를 돌며 대기를 함. S--; // 자원을 획득함.}signal(S) { S++; // 자원을 해제함.}// 자원이 없다면 blocked 상태에서 기다리는 방식typedef struct{ int value; /* semaphore */ struct process *list; /* process wait queue */} semaphore;wait(semaphore *S) { S-&gt;value--; if (S-&gt;value &lt; 0 ) { // 자원이 없다면 add this process to S-&gt;list; // 프로세스를 큐에 넣고 block(); // block 시킴 }}signal(semaphore *S) { S-&gt;value++; if (S-&gt;value &lt;= 0) { // 자원이 0이하라면 block중인 프로세스가 있다는 의미임. remove a process P from S-&gt;list; // 대기하고 있는 프로세스를 가져옴. wakeup(P); // 가져온 프로세스를 깨움. }} Semaphore Busy waiting 문제를 해결함 이진 세마포어 0 또는 1 값만 가질 수 있는 세마포어 임계 구역 문제를 해결하는데 사용하며 자원이 하나이기 때문에 뮤텍스로도 사용할 수 있다. 개수 세마포어 도메인이 0이상인 임의의 정수값인 세마포어 여러개의 자원을 가질 수 있으며 제한된 자원을 가지고 액세스 작업을 할 때 사용한다. Eventcount/sequencer 은행의 번호표와 비슷한 개념 Sequencer 정수형 변수 생성 시 0으로 초기화, 감소하지 않음 발생 사건들의 순서 유지 ticket() 연산으로만 접근 가능 ticket(S) 현재까지 ticket() 연산이 호출 된 횟수를 반환 eventcount 정수형 변수 생성시 0으로 초기화, 감소하지 않음 특성 사건의 발생 횟수를 기록 read(E), advance(E), await(E, v) 연산으로만 접근 가능 read(E) 현재 Eventcount 값 반환 advance(E) E &lt;- E + 1 E를 기다리고 있는 프로세스를 깨움(wake-up) await(E, v) V는 정수형 변수 if(E &lt; v)이면 E에 연결된 Qe에 프로세스 전달(push) 및 CPU scheduler 호출 No busy waiting No starvation Semaphore보다 더 low-level control이 가능 (순서를 컨트롤 할 수 있음)Language-Level solution Monitor 공유 데이터와 Critical section 의 집합 한 번에 하나의 프로세스만 모니터 개체 내에 프로시저를 사용할 수 있습니다. 모니터에 접근하지 못한 프로세스는 entry queue에서 대기하게 된다. (상호배제) 모니터 개체 내 공유 자원은 직접 접근할 수 없으며 프로시저를 통해서만 가능합니다. (정보은닉) " }, { "title": "[OS] 병행 프로세스(1)", "url": "/posts/OS-%EB%B3%91%ED%96%89-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4(1)/", "categories": "Computer Science, OS", "tags": "OS", "date": "2022-03-22 10:00:00 +0900", "snippet": "병행 프로세스동시에 실행되는 여러 개의 프로세스 또는 쓰레드CPU 개수에 따른 병행 프로세스의 실행 형태 한 개의 CPU 각 프로세스가 짧은 시간 간격으로 번갈아 실행되는 인터리빙 형식으로 진행 여러 개의 CPU 각 프로세스가 각 CPU에서 온전히 실행되는 병행 처리 형식으로 진행 메모리 구조에 따른 병행 프로세스 실행 형태 강결합 멀티프로세서 시스템 여러 CPU 간에 하나의 기억장치를 공유하며 하나의 운영체제가 모든 CPU와 시스템 하드웨어를 제어 - 공유 메모리 구조 약결합 멀티프로세서 시스템 2개 이상의 독립된 컴퓨터 시스템을 통신선을 통하여 연결 - 분산 메모리 구조 각 시스템은 자신의 운영체제와 기억장치를 가지고 있으며 독립적으로 운영되고 필요할 때만 통신을 한다. 병행성 문제 병행 프로세스들이 상호작용 하는 경우 발생 공유 자원 점유 문제 동기화 문제 통신 문제 단일 프로세스 내의 병행성 우선순위 그래프 각 정점이 개개의 문장에 대응하는 사이클이 없는 방향 그래프 Fork/Join 구조 fork : 프로그램 내에서 2개의 병행 수행을 만들어 낸다. join : 병행하는 n개의 연산을 하나로 재결합 시키는 방법을 제공한다. 병행문 1개의 프로세스가 여러 가닥의 병렬 프로세스로 분할되었다가 다시 하나로 결합 프로세스 간의 병행성 비동기 병행 프로세스 어떤 프로세스가 실행 중인 다른 프로세스에 영향을 주는 유기적 프로세스 동기화와 임계영역경쟁 상태 (Race Condition) 여러 프로세스가 동시에 공유 데이터로 접근 할 때 순서에 따라 결과가 달라지는 현상. 여러 주체가 하나의 데이터에 접근하려 할 때 서로 경쟁하는 상태를 의미한다.임계영역 2개 이상의 프로세스가 동시에 액세스하면 안 되는 공유자원을 액세스하는 코드 영역 임계영역 문제 해결을 위한 요구조건 상호배제 한 프로세스가 임계영역에서 실행 중일 때 다른 어떤 프로세스도 임계영역에서 실행될 수 없음 진행 임계영역에서 실행 중인 프로세스가 없고 여러 프로세스가 임계영역에 진입하고자 할 때 그 중에서 적절히 한 프로세스를 결정해야 하며 이 결정은 무한정 미룰 수 없음 제한된 대기 한 프로세스가 임계영역 진입 요청을 한 후 수락될 때까지 다른 프로세스가 임계영역 진입을 허가 받는 횟수는 제한이 있어야 함 상호 배제 해결 방법 SW solutions Dekker’s algorithm (Peterson’s algorithm) Dijkstra’s algorithm, Knuth’s algorithm, Eisenberg and McGuire’s algorithm, Lamport’salgorithm HW solution TestAndSet(TAS) instruction OS supported SW solution Spinlock Semaphore Eventcount/sequencer Language-Level solution Monitor " }, { "title": "[OS] CPU 스케줄링", "url": "/posts/OS-CPU-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/", "categories": "Computer Science, OS", "tags": "OS", "date": "2022-03-21 10:00:00 +0900", "snippet": "CPU 스케줄링주어진 프로세스들이 여러 개인 경우 어떤 순서대로 CPU를 얼마 동안 배정하여 프로세스를 처리할지를 결정하는 스케줄링CPU 스케줄링 단계 상위단계 스케줄링 시스템에 들어오는 작업들을 선택하여 프로세스를 생성한 후 프로세스 준비 큐에 전달하는 역할 입출력(I/O) 중심 작업과 연산 중심 작업을 균형있게 선택하도록 작업 순서를 결정한다. 중간단계 스케줄링 CPU를 할당받으려는 프로세스가 많을 경우 프로세스를 임시 대기 시킨 후 활성화하여 시스템에 대한 부하를 조절하는 역할 하위단계 스케줄링 사용 가능한 CPU를 준비상태의 어느 프로세스에 할당할지를 결정하는 역할 * 디스패처 ? 스케줄러가 어떤 프로세스를 기준에 맞게 선택한다면 선택된 프로세스를 CPU에 할당해주는 실제적인 실행 주체 문맥 교환이 일어날 때 이전의 프로세스의 상태를 저장하고 다음 프로세스를 복원하는 실제 처리 과정을 담당 스케줄링 기법 선점 스케줄링 진행 중인 작업에 인터럽트를 걸고 다른 작업에 CPU를 할당하는 스케줄링 방식 우선 순위가 높은 프로세스를 긴급하게 처리 해야 할 경우 유용 잦은 문맥 교환에 따른 오버헤드가 발생할 수 있다. 비선점 스케줄링 프로세스가 CPU를 할당받아 실행이 시작되면 프로세스 자체가 I/O 인터럽트를 걸거나 프로세스를 종료할 때까지 다른 프로세스가 강제로 CPU를 뺴앗을 수 없는 스케줄링 방식 모든 프로세스가 우선순위에 관계없이 실행되지만 프로세스의 배치에 따라 효율 차이가 발생할 수 있다. 스케줄링 성능 기준 시스템(CPU) 관점 CPU 이용률(CPU utilization)전체 시간 중에서 CPU가 일을 한 시간의 비율 처리량(thoughtput) 주어진 시간 동안 대기 큐에서 기다리고 있는 프로세스 중 CPU 버스트를 처리한 개수 사용자(프로세스) 관점 반환 시간(Turn-around time) 프로세스가 생성된 후 종료되어 사용하던 자원을 모두 반환하는 데까지 걸리는 시간, 즉 대기 큐에서 대기한 시간과 실제로 CPU를 사용한 시간의 합 대기 시간(Waiting time) 프로세스가 CPU를 할당받아 실행되기 전 대기 상태일 때의 시간 응답 시간(Response time) 프로세스가 대기 큐에 들어온 후 최초로 CPU를 얻기까지 기다린 시간 CPU 스케줄링 알고리즘 FCFS 스케줄링 (First-Come First-Served) 대기 큐에서 도착순서에 따라 디스패치되며, 일단 프로세스가 CPU를 차지하면 그 프로세스의 수행이 완료된 후에 다음 프로세스가 CPU를 차지하고 수행되는 비선점형 방식 짧은 작업이 긴 작업을 기다리게 되기도 하고 중요한 프로세스가 나중에 수행될 수도 있기 때문에 대화식 시스템에는 적합하지 않다. SJP 스케줄링 (Shortest Job First) 대기 큐에서 기다리는 프로세스 중 실행 시간이 짧다고 예상되는 것을 먼저 수행하는 비선점형 방식 처리 시간이 긴 프로세스의 경우 처리 시간이 짧은 프로세스가 계속해서 들어오는 경우 CPU를 할당받지 못한다. 실제 대기 상태에 있는 프로세스의 실행 시간을 정확하게 예상하기 어렵다. SRTF 스케줄링 (Shortest Remaning Time First) SJF 스케줄링의 선점형 방식, 먼저 들어온 프로세스가 CPU를 할당받았더라도 남은 처리 시간이 뒤에 온 프로세스의 실행 시간보다 길면 뒤에 온 프로세스에 CPU를 할당하는 방식 잦은 문맥 교환이 일어나고 그에 따른 오버헤드가 커진다. RR 스케줄링 (Round-Robin) 프로세세에게 각각 동일한 CPU 할당 시간(time quantum)을 부여하여 실행하는 선점형 방식 모든 프로세스가 최초 응답 시간을 빠르게 보장 받을 수 있기 때문에 여러 종류의 프로세스가 같이 실행되는 환경에서 효과적이다. 할당 시간이 너무 짧을 경우 잦은 문맥 교환으로 오버헤드가 발생할 수 있고, 할당 시간이 긴 경우에는 CPU의 효율성이 떨어지고 FCFS 스케줄링과 다를 바 없어진다. HRN 스케줄링 (Highest Responese Ratio Next) 대기 큐에서 기다리는 프로세스 중 응답비율이 가장 큰 것을 먼저 디스패치하여 실행하는 비선점형 방식 수행시간의 길이와 대기 시간을 모두 고려하여 우선순위를 정해 SJF 스케줄링의 단점을 보완할 수 있다. 다단계 큐 스케줄링 (Multi-level Queue) 우선순위에 따라 준비 큐를 여러 개로 분할하여 관리하는 방식 프로세스는 운영체제로부터 부여받은 우선순위에 따라 해당 우선순위의 큐에 삽입된다. 우선순위는 고정형 우선순위를 사용하며 상단의 큐에 있는 모든 프로세스의 작업이 끝나야 다음 우선순위 큐의 작업이 시작된다. 다단계 피드백 큐 스케줄링 (Multi-level Feedback Queue) 우선순위가 낮은 프로세스에 불리한 다단계 큐 스케줄링의 문제점을 보완하는 선점형 방식 다단계 큐 스케줄링은의 경우 우선순위에는 변화가 없지만, 다단계 피드백 큐 스케줄링의 경우 CPU를 사용하고 난 뒤 프로세스의 우선순위가 낮아지며, 원래 큐로 되돌아가지 않고 우선순위가 하나 낮은 큐의 끝으로 들어간다. " }, { "title": "[Spring] RESTful API 제대로 알아보기", "url": "/posts/Spring-REST-API-%EC%9D%91%EB%8B%B5%ED%95%98%EA%B8%B0/", "categories": "Programming, Spring", "tags": "Spring", "date": "2022-02-23 10:00:00 +0900", "snippet": "REST란 HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원(URI)에 대한 CRUD Operation을 적용하는 것을 의미합니다. HTTP URI를 통해 자원을 명시하고, HTTP Method (POST,GET,PUT,DELETE)를 통해 해당 자원에 대한 CRUD OPERATION을 적용하는 것을 의마한다. 즉, REST는 자원 기반의 구조 설계의 중심에 Resource가 있고 HTTP Method를 통해 Resource를 처리하도록 설계된 아키텍쳐를 의미한다. 웹의 모든 자원에 고유한 ID인 HTTP URI를 부여한다.REST 기본 구성 REST API는 REST(REpresentational State Transfer) 아키텍처 스타일의 디자인 원칙을 준수하는 API입니다. 자원 (Resource) - URL 모든 자원에 고유한 ID가 존재하고, 이 자원은 Server에 존재한다. 행위 (Verb) - Http Method 기본 Method Method 의미 역할 POST Create POST를 통해 해당 URI를 요청하면 리소스를 생성한다. GET Select GET를 통해 해당 리소스를 조회한다. 리소스를 조회하고 해당 도큐먼트에 대한 자세한 정보를 가져온다. PUT Update PUT를 통해 해당 리소스를 수정한다. DELETE Delete DELETE를 통해 해당 리소스를 삭제한다. 표현 (Representations) Client가 자원의 상태(정보)에 대한 조작을 요청하면 Server는 이에 적절한 응답을 보낸다. REST에서 하나의 자원은 JSON, XML, TEXT, RSS 등 여러 형태의 Representation으로 나타낼 수 있다. 현재는 대부분 JSON으로 주고받는다. REST 특징 클라이언트 / 서버 구조 클라이언트는 유저와 관련된 처리를, 서버는 REST API를 제공함으로서 각각의 열할이 확실하게 구분되고 일괄적인 인터페이스로 분리되어 작동할 수 있게 한다. REST Server : API를 제공하고 비지니스 로직 처리 및 저장을 책임진다. Client : 사용자 인증이나 context(세션, 로그인정보) 등을 직접 관리하고 책임진다. 서로간의 의존성이 줄어든다. 무상태성 (Stateless) REST는 HTTP의 특성을 이용하기 때문에 무상태성을 갖는다. 즉 서버에서 어떤 작업을 하기 위해 상태정보를 기억할 필요가 없고 들어온 요청에 대해ㅐ 처리만 해주면 되기 때문에 구현이 쉽고 단순해진다. 캐시 처리 기능 (Cacheable) HTTP라는 기존 웹표준을 사용하는 REST의 특징 덕분에 기본 웹에서 사용하는 인프라를 그대로 사용 가능하다. 대량의 요청을 효율적으로 처리하기 위해 캐시가 요구된다. 캐시 사용을 통해 응답시간이 빨라지고 REST Server 트랜잭션이 발생하지 않기 때문에 전체 응답시간, 성능, 서버의 자원 이용률을 향상 시킬 수 있다. 자체 표현 구조 (Self - descriptiveness) JSON을 이용한 메세지 포맷을 이용하여 직관적으로 이해할 수 있고 REST API 메세지만으로 그 요청이 어떤 행위를 하는지 알 수 있다. 계층화 (Layered System) 클라이언트와 서버가 분리되어 있기 때문에 중간에 프록시 서버, 암호화 계층 등 중간매체를 사용할 수 있어 자유도가 높다. 유니폼 인터페이스 (Uniform) Uniform Interface는 HTTP 표준에만 따른다면 모든 플랫폼에서 사용이 가능하며, URI로 지정한 리소스에 대한 조작을 가능하게 하는 아키텍쳐 스타일을 말한다. URI로 지정한 Resource에 대한 조작을 통일되고 한정적인 인터페이스로 수행한다. 즉, 특정 언어나 기술에 종속되지 않는다. REST API 중심규칙 URI는 정보의 자원을 표현해야 한다. 자원에 대한 행위는 HTTP Method로 표현한다. 유의 슬래시 구분자(/)는 계층 관계를 나타내는데 사용한다. URI 마지막 문자로 슬래시를 포함하지 않는다. 즉 URI에 포함되는 모든 글자는 리소스의 유일한 식별자로 사용되어야 하며 URI가 다르다는 것은 리소스가 다르다는 것 역으로 리소스가 다르면 URI도 달라져야 한다. 하이픈(-)은 URI 가독성을 높이는데 사용하며 밑줄(_)은 사용하지 않는다. URI 경로에는 소문자가 적합하다. user/viewUser (x) user/view-user (o) 파일 확장자는 URI에 포함하지 않는다. REST API 에서는 메세지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI안에 포함시키지 않는다. 대신 Accept Header 사용 ex) GET orders/2/Accept: image/jpg 리소스간에 연관 관계가 있는 경우 /리소스명/리소스ID/관계가 있는 다른 리소스명 ex) GET /users/2/orders (일반적으로 소유의 관계를 표현할 때 사용) RESTful API 디자인 리소스와 행위를 명시적이고 직관적으로 분리해야한다. Messaage 는 Header와 Body를 명확하게 분리해서 사용한다. API 버전을 관리한다. 서버와 클라이언트가 같은 방식을 사용해서 요청하도록 한다.RESTful API 장단점 Open API를 제공하기 쉽다. 멀티플랫폼 지원 및 연동이 용이하다. 원하는 타입으로 데이터를 주고 받을 수 있다. 기존 웹 인프라(HTTP)를 그대로 사용할 수 있다. 사용할 수 있는 메소드가 한정적이다. 분산환경에는 부적합하다. HTTP 통신 모델에 대해서만 지원한다." }, { "title": "[AWS] RDS 생성하기", "url": "/posts/AWS-RDS-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0/", "categories": "Programming, AWS", "tags": "AWS", "date": "2021-06-01 10:00:00 +0900", "snippet": "RDS 생성하기 RDS 데이터베이스 생성 MariaDB - 프리티어 DB 인스턴스 식별자 설정 마스터 이름, 암호 설정 할당된 스토리지 20GiB 설정 퍼블릭 엑세스 가능 - 예 생성 완료 파라미터 그룹 생성 생성한 파라미터 그룹 편집 데이터베이스 파라미터 그룹 변경 보안그룹 편집 " }, { "title": "[AWS] EC2 서버 접속하기", "url": "/posts/AWS-EC2-%EC%84%9C%EB%B2%84-%EC%A0%91%EC%86%8D%ED%95%98%EA%B8%B0/", "categories": "Programming, AWS", "tags": "AWS", "date": "2021-05-31 12:00:00 +0900", "snippet": "EC2 서버에 접속하기Putty를 사용하여 접속하기(윈도우 기준) putty 설치 https://www.chiark.greenend.org.uk/~sgtatham/putty/releases/0.75.html putty.exe, puttygen.exe 다운로드 puttygen.exe 실행 Conversions - Import Key 다운받은 pem 파일 선택 - Save private key putty.exe 실행 HostName : ec2-user@탄력적IP 입력 Connection - SSH - Auth - ppk 설정 Open - ec2-user 서버 생성 시 꼭 해야하는 설정들 java 설치 - sudo yum install -y java-1.8.0-openjdk-devel.x86_64 // java 8 설치- $ sudo /usr/sbin/alternatives --config java // java 버전 변경- java -version // java 버전 확인 타임존 변경 - sudo rm /etc/localtime - sudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime HostName 변경 - sudo hostnamectl set-hostname webserver.localdomain- sudo reboot- hostname " }, { "title": "[AWS] Elastic IP 할당하기", "url": "/posts/AWS-Elastic-IP-%ED%95%A0%EB%8B%B9%ED%95%98%EA%B8%B0/", "categories": "Programming, AWS", "tags": "AWS", "date": "2021-05-31 11:00:00 +0900", "snippet": "Elastic IP(EIP, 탄력적 IP) 할당하기 인스턴스도 IP가 존재하는데 같은 인스턴스를 중지하고 다시 시작할 때도 새 IP가 할당된다. 매번 변경되지 않고 고정 IP를 가지게 하기 위해 고정 IP를 할당해야한다. 탄력적 IP - 탄력적 IP 주소 할당 탄력적 IP 주소 설정 탄력적 IP 주소 할당 완료 탄력적 IP 주소 연결 확인 생성한 탄력적 IP는 무조건 EC2에 바로 연결해야 하며 만약 더는 사용할 인스턴스가 없을 때도 탄력적 IP를 삭제해야합니다. " }, { "title": "[AWS] EC2 인스턴스 생성", "url": "/posts/AWS-EC2-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%83%9D%EC%84%B1/", "categories": "Programming, AWS", "tags": "AWS", "date": "2021-05-31 10:00:00 +0900", "snippet": "EC2 인스턴스 생성 AWS 회원가입 AWS : 첫 가입시 대부분 서비스가 1년동안 무료 EC2 - 인스턴스 시작 EC2 : AWS에서 제공하는 성능, 용량 등을 유동적으로 사용할 수 있는 서버 사양은 t2.micro만 가능 월 750시간의 제한 Amazon Machine Image(AMI) - Amazon Linux 2 AMI 선택 AMI : EC2 인스턴스를 시작하는 데 필요한 정보를 이미지로 만들어 둔 것 인스턴스 유형 - t2.micro 선택 t2는 요금타입, micro는 사양 인스턴스 세부 정보 구성 기본값으로 설정 스토리지 추가 크기 (최대 30GB까지 프리티어로 가능) 보안 그룹 구성 방화벽을 의미한다. pem 키 관리와 지정된 IP에서만 ssh 접속이 가능하도록 구성하는 것이 안전하다. 새 키 페어 생성 - 키 페어 다운로드 - 인스턴스 시작 인스턴스는 지정된 pem 키(비밀키)와 매칭되는 공개키를 가지고 있어 해당 pem 키 외에는 접근을 허용하지 않습니다. pem 키는 이후 EC2 서버로 접속할 때 필수 파일이기 때문에 잘 관리할 수 있는 디렉토리로 저장합니다. 인스턴스 생성 완료 " }, { "title": "[AWS] Maven으로 Project 배포", "url": "/posts/AWS-Maven%EC%9C%BC%EB%A1%9C-Project-%EB%B0%B0%ED%8F%AC/", "categories": "Programming, AWS", "tags": "AWS", "date": "2021-05-31 09:00:00 +0900", "snippet": "Maven으로 war 파일 만들기 pom.xml에 plugin 추가 &lt;build&gt; \t&lt;plugins&gt; \t\t&lt;plugin&gt; \t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; \t\t&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; \t&lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; Maven - Lifecycle - package 실행 /target/axboot-1.0.0.war 생성 cmd 명령어 실행 C:\\Project\\deploy&gt;java -jar axboot-1.0.0.war 정상 실행됨 " }, { "title": "[JPA] LazyInitializationException", "url": "/posts/JPA-LazyInitializationException/", "categories": "Programming, JPA", "tags": "JPA, SpringBoot", "date": "2021-05-26 10:00:00 +0900", "snippet": "org.hibernate.LazyInitializationException Reservation.java @Entitypublic class Reservation extends BaseJpaModel&lt;Long&gt; { @Id @Column(name = \"ID\", precision = 19, nullable = false) @GeneratedValue(strategy = GenerationType.IDENTITY) @ColumnPosition(1) private Long id; ... @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY) @NotFound(action = NotFoundAction.IGNORE) @JoinColumn(name = \"RSV_NUM\", referencedColumnName = \"RSV_NUM\", insertable = false, updatable = false) private List&lt;ReservationMemo&gt; memoList;} ReservationResponseDto.java @Getterpublic class ReservationResponseDto { private Long id; ... private List&lt;ReservationMemo&gt; memoList = new ArrayList&lt;ReservationMemo&gt;(); public ReservationResponseDto (Reservation entity) { this.id = entity.getId(); ... for (ReservationMemo memo : entity.getMemoList()) { if(memo.getDelYn().equals(\"N\")) { this.memoList.add(memo); } } }} ReservationServiceTest.java @Log @RunWith(SpringRunner.class) @SpringBootTest(classes = AXBootApplication.class) @FixMethodOrder(MethodSorters.NAME_ASCENDING) public class ReservationServiceTest { private static Logger logger= LoggerFactory.getLogger(ReservationServiceTest.class); @Autowired private ReservationService reservationService; \t @Test public void test2_예약_상세조회() { ReservationResponseDto dto = reservationService.selectOne(1752L); assertTrue(dto.getId() == 1752L); } } 오류메세지 @OneToMany 어노테이션으로 매핑된 Reservation(주인 객체)와 ReservationMemo(종속 객체)를 조회하는 테스트코드를 실행했을 때 LazyInitializationException 오류 발생. 원인 영속성 컨텍스트에 있던 Entity가 준영속(Detached) 상태가 됐을 때 Lazy Loading을 실행해서 영속성 컨텍스트에서 해당 객체를 조회해오려고 했을 때 발생 (출처: https://dundung.tistory.com/237 [DunDung]) 조회결과가 반환되며 트랜잭션이 이미 종료된 이후에 MemoList에 접근하려 했기 때문에 해결방법 @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER) 로 FetchType 옵션 변경 (즉시 로딩) 문제점 즉시 로딩을 사용할 경우 예상하지 못한 SQL이 발생할 수 있다. 즉시 로딩은 JPQL 사용 시 N+1 문제를 유발한다. 단위 테스트 메소드에 @Transactional 어노테이션 추가 메소드 전체를 하나의 트랜잭션으로 감싸 정상적으로 조회 가능 " }, { "title": "[Querydsl] 동적으로 조건문 만들기", "url": "/posts/Querydsl-%EB%8F%99%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%A1%B0%EA%B1%B4%EB%AC%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "Programming, JPA", "tags": "JPA, Querydsl", "date": "2021-05-23 10:00:00 +0900", "snippet": "Queydsl에서 조건문을 생성하는 방법 조건문을 생성하는 방법에는 BooleanBulider와 BooleanExpression을 사용하는 방법이 있다.BooleanBuilder if문으로 필요한 조건문만을 추가하여 쿼리를 만들 수 있다.public List&lt;Member&gt; list(String name, String age, String tel) {\tBooleanBulider bulider = new BooleanBulider(); \tif(isNotEmpty(name)) { bulider.and(member.name.eq(name)); }\tif(isNotEmpty(age)) { bulider.and(member.name.eq(age)); }\tif(isNotEmpty(tel)) { bulider.and(member.name.eq(tel)); } List&lt;Member&gt; list=select() .from(qmember) .where(bulider) .fetch(); return list;}BooleanExpression BooleanExpression 타입을 리턴하는 메서드를 만들어 조건을 추가 할 수 있다. 메서드로 만들어 사용하기 때문에 재사용이 가능하며 어떤 조건인지 명확히 알 수 있다.public List&lt;Member&gt; list(String name, String age, String tel) {\t List&lt;Member&gt; list=select() .from(qmember) .where(nameEq(name),telEq(tel)) .fetch(); return list;}private BooleanExpression nameEq(String name) { return name != null ? member.name.eq(name) : null;}private BooleanExpression telEq(String tel) { return tel!= null ? member.tel.eq(tel) : null;}" }, { "title": "[JavaScript] Moment.js", "url": "/posts/JavaScript-Moment.js/", "categories": "Programming, JavaScript", "tags": "JavaScript", "date": "2021-05-20 10:00:00 +0900", "snippet": "Moment.js 날짜를 손쉽게 다루는 javascript 라이브러리moment() 현재 날짜 값format()moment().format('YYYY-MM-DD') // 현재 날짜를 YYYY-MM-DD 형식으로 formatadd()moment().add(1, 'days') // 현재 날짜로부터 1일 후moment().add(1, 'months') // 현재 날짜로부터 1개월 후moment().add(1, 'years') // 현재 날짜로부터 1년 후 subtract()moment().subrtract(1, 'days') // 현재 날짜로부터 1일 전moment().subrtract(1, 'months') // 현재 날짜로부터 1개월 전moment().subrtract(1, 'years') // 현재 날짜로부터 1년 전diff()moment('2021-05-20').diff('2021-05-21', 'days') // 현재 날짜로부터 날짜 간격 (일단위)moment('2021-05-20').diff('2021-06-21', 'months') // 현재 날짜로부터 날짜 간격 (월 단위)moment('2021-05-20').diff('2022-05-21', 'years') // 현재 날짜로부터 날짜 간격 (년단위)isBefore(), isAfter()moment().isBefore('2021-05-19') // 현재 날짜로부터 이전 날짜인지 비교moment().isAfter('2021-05-21') // 현재 날짜로부터 이후 날짜인지 비교isBetween()moment('2021-05-20').isBetween('2021-05-19', '2021-05-21'); // 두 날짜 사이의 값이 맞는지 비교 참고 : https://momentjs.com/" }, { "title": "[Spring] @Autowired,@Resource,@Inject", "url": "/posts/Spring-@Autowired,@Resource,@Inject/", "categories": "Programming, Spring", "tags": "Spring", "date": "2021-05-19 10:00:00 +0900", "snippet": " 모두 DI(의존성 주입) 을 위해 사용한다. 특정 Bean 기능을 수행하기 위해 기능에 필요한 특정한 Bean을 참조해야 하는데 이 때 특정 Bean에 자동 연결을 위해 위 어노테이션들을 사용한다. @Autowired 스프링 프레임워크에서 제공하는 어노테이션이기 때문에 타 프레임워크에서는 사용할 수 없다. 속성, Setter, 생성자에 모두 사용 가능하며 주입하려는 객체 타입이 일치하는 객체를 자동으로 주입 기본적으로 특정 빈을 찾지 못하면 예외를 던진다. 이 때 required 속성값을 false로 지정할 경우에는 빈 객체가 존재하지 않더라도 예외처리를 발생시키지 않는다. @Qualifier 동일한 타입의 빈 객체가 여러개 정의되어 있을 경우 XML 설정파일에서 우선적으로 사용할 빈 객체의 태그 하위에 태그를 설정한다. @Autowired와 함께 @Qualifier를 사용하여 XML 설정 파일에서 설정한 태그의 value 값을 지정해준다. 이렇게 하면 동일한 타입의 빈이 여러 개일 경우 우선적으로 특정 빈이 주입된다. @Resource 자바에서 지원하는 어노테이션이기 때문에 프레임워크에 비종속적이다. 속성, Setter에서 사용 가능하며 주입하려는 객체 이름이 일치하는 객체를 자동으로 주입, 생성자는 사용할 수 없다. Resource를 통해 자동 주입을 하려면 주입하려는 Class에서 Bean의 id 이름과 동일해야 한다.@Inject 자바에서 지원하는 어노테이션이기 때문에 프레임워크에 비종속적이다. @Inject를 사용하기 위해서는 maven이나 gradle에 javax 라이브러리 의존성을 추가해야한다. 속성, Setter, 생성자에 모두 사용 가능하며 주입하려는 객체 타입이 일치하는 객체를 자동으로 주입 @Autowired와 비슷하지만 Qualifier 대신 명시적으로 Bean을 표기한다. @Named @Autowired의 @Qualifier와 유사하지만 @Named에는 빈 이름(id)를 지정하므로 @Qualifier를 사용할 때에 비해 XML 설정 파일이 다소 짧아진다는 특징이 있다. XML 설정 파일에 추가적으로 설정할 것이 없으며 @Inject와 함께 @Named를 사용하여 빈 이름을 지정해야한다. " }, { "title": "[Javascript] 배열 내장함수", "url": "/posts/Javascript-%EB%B0%B0%EC%97%B4-%EB%82%B4%EC%9E%A5%ED%95%A8%EC%88%98/", "categories": "Programming, JavaScript", "tags": "JavaScript, JQuery", "date": "2021-05-05 10:00:00 +0900", "snippet": "배열 내장함수Array.prototype.forEach() 주어진 함수를 배열 요소 각각에 대해 실행합니다. 예시 const a=[1,2,3,4,5]; for(let i=0; i&lt;a.length; i++) {\tconsole.log(a[i]);} // 출력 : 1, 2, 3, 4, 5 Array.prototype.map() 배열 내의 모든 요소 각각에 대하여 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환합니다. 예시 const a=[1,2,3,4,5]; const b=a.map(function(s) {\treturn s*s;}) console.log(b); // 출력 : [1, 4, 9, 16, 25] Array.prototype.filter() 주어진 함수의 테스트를 통과하는 모든 요소를 모아 새로운 배열로 반환합니다. 예시 const a=[1,2,3,4,5]; const b=a.filter(function(s) {\treturn s%2==0;}) console.log(b); // 출력 : [2, 4] Array.prototype.indexOf() 배열에서 지정된 요소를 찾을 수 있는 첫 번째 인덱스를 반환하고 존재하지 않으면 -1을 반환합니다. 예시 const a = ['호랑이', '사자', '고양이', '멍멍이'];console.log(a.indexOf('고양이')); // 출력 : 2 Array.prototype.findIndex() 주어진 판별 함수를 만족하는 배열의 첫 번째 요소에 대한 인덱스를 반환합니다. 만약 만족하는 요소가 없는 경우에는 -1을 반환합니다. 예시 const a = [ { name : '호랑이' }, { name : '사자' }, { name : '고양이' }, { name : '멍멍이' }]console.log(a.findIndex(ary =&gt; ary.name === '고양이')); // 출력 : 2 Array.prototype.find() 주어진 판별 함수를 만족하는 첫 번째 요소의 값을 반환합니다. 그런 요소가 없다면 undefined를 반환합니다. 예시 const a = [ { name : '호랑이' }, { name : '사자' }, { name : '고양이' }, { name : '멍멍이' }]console.log(a.find(ary =&gt; ary.name === '고양이')); // 출력 : {name: '고양이'} Array.prototype.splice() 배열의 기존 요소를 삭제 또는 교체하거나 새 요소를 추가하여 배열의 내용을 변경합니다. 예시 const a = [1,2,3,4,5]; const b = a.splice(0,2,10,11); console.log(b); // 출력 : [1,2]console.log(a); // 출력 : [10,11,3,4,5] Array.prototype.slice() splice 메서드와는 다르게 해당 구간 인덱스만을 가지는 새로운 배열을 반환하며 원본 배열은 바뀌지 않는다. 예시 const a = [1,2,3,4,5]; const b = a.slice(1,3); console.log(b); // 출력 : [2,3]console.log(a); // 출력 : [1,2,3,4,5] Array.prototype.reduce() 배열의 각 요소에 대해 주어진 reducer 함수를 실행하고, 하나의 결과값을 반환합니다. 예시 const a = [1,2,3,4,5]; const b = a.reduce(function(a,b) { return a + b;},0) console.log(b); // 출력 : 15 Array.prototype.shift() / Array.prototype.pop() shift() : 배열에서 첫 번째 요소를 제거하고, 제거된 요소를 반환합니다. pop() : 배열에서 마지막 요소를 제거하고 그 요소를 반환합니다. 예시 const a=[1,2,3,4,5]; a.shift();console.log(a); // 출력 : [2,3,4,5]a.pop();console.log(a); // 출력 : [2,3,4] Array.prototype.unshift() / Array.prototype.push() unshift() : 새로운 요소를 배열의 맨 앞쪽에 추가하고, 새로운 길이를 반환합니다. push() : 배열의 끝에 하나 이상의 요소를 추가하고, 배열의 새로운 길이를 반환합니다. 예시 const a=[1,2,3,4,5]; a.unshift(10);console.log(a); // 출력 : [10,1,2,3,4,5]a.push(11);console.log(a); // 출력 : [10,1,2,3,4,5,11] Array.prototype.concat() 인자로 주어진 배열이나 값들을 기존 배열에 합쳐 새 배열을 반환합니다. 예시 const arr1=[1,2,3];const arr2=[4,5,6]; const concated=arr1.concat(arr2);console.log(concated); // 출력 : [1,2,3,4,5,6] Array.prototype.join() 배열의 모든 요소를 연결해 하나의 문자열로 만듭니다. 예시 const a=[1,2,3,4,5];console.log(a.join('*')); // 출력 : 1*2*3*4*5 " }, { "title": "[Spring] Entity와 DTO", "url": "/posts/Spring-Entity%EC%99%80-DTO/", "categories": "Programming, Spring", "tags": "Spring, SpringBoot", "date": "2021-05-03 10:00:00 +0900", "snippet": "Entity와 DTOEntity 실제 DB의 테이블과 1:1로 매핑되는 클래스로 DB 테이블 내에 존재하는 컬럼만을 속성으로 가져야한다. 상속을 받거나 구현체여서는 안된다. 테이블내에 존재하지 않는 컬럼을 가지면 안된다. 예시 @Getter@NoArgsConstructor@Entity@Table(name = \"POSTS\")public class Posts extends BaseTimeEntity { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(length = 500, nullable = false) private String title; @Column(columnDefinition = \"TEXT\", nullable = false) private String content; private String author; @Builder public Posts(String title, String content, String author) { this.title=title; this.content=content; this.author=author; } public void update(String title, String content) { this.title=title; this.content=content; }} @Entity - 테이블과 매핑할 클래스 속성 name : JPA에서 사용할 엔티티 이름 기본값 : 클래스 이름을 그대로 사용 @Table - Entity가 매핑될 테이블을 지정한다 속성 Name : 매핑할 테이블 이름 기본값 : 엔티티 이름을 사용 Catalog : catalog 기능이 있는 DB에서 catalog를 매핑 schema : schema 기능이 있는 DB에서 schema를 매핑 uniqueConstraints : DDL 생성시 유니크 제약조건 생성 @Getter - 클래스 내 모든 필드의 Getter 메소드를 자동 생성 @NoArgsConstructor - 파라미터가 없는 기본 생성자를 생성, protected Posts() {}와 같은 효과 @Id - 해당 테이블의 pk 필드 매핑 @Column - 컬럼 매핑 속성 name : 객체명과 DB 컬럼명을 다르게 하고 싶은 경우, DB 컬럼명으로 설정할 이름을 적는다. length : 문자 길이 제약 조건, String 타입에만 사용 nullable : NOT NULL 제약조건 @Builder - 해당 클래스의 빌더 패턴 클래스 생성, 생성자 상단에 선언 시 생성자에 포함된 필드만 빌더에 포함 DTO 계층간 데이터 교환을 위한 객체, 주로 비동기 처리에 사용 getter/setter 메서드만을 갖는다 Request와 Response용 DTO는 View를 위한 클래스 예시 @Getter@NoArgsConstructorpublic class PostsSaveRequestDto { private String title; private String content; private String author; @Builder public PostsSaveRequestDto(String title, String content, String author) { this.title=title; this.content=content; this.author=author; } public Posts toEntity() { return Posts.builder() .title(title) .content(content) .author(author) .build(); }} Entity 클래스와 DTO 클래스를 분리하는 이유 수많은 서비스 클래스나 비지니스 로직들이 Entity 클래스를 기준으로 동작하기 때문에 Entity 클래스가 변경되면 여러 클래스에 영향을 끼치게 된다. Controller에서 결과값으로 여러 테이블을 조인해서 줘야하는 경우가 빈번하기 때문에 Entity 클래스만으로는 표현하기가 어려운 경우가 많다." }, { "title": "[Javascript] 얕은 복사와 깊은 복사", "url": "/posts/Javascript-%EC%96%95%EC%9D%80-%EB%B3%B5%EC%82%AC%EC%99%80-%EA%B9%8A%EC%9D%80-%EB%B3%B5%EC%82%AC/", "categories": "Programming, JavaScript", "tags": "JavaScript", "date": "2021-04-23 10:00:00 +0900", "snippet": "얕은 복사와 깊은 복사얕은 복사(Shallow Copy) 객체를 복사할 때, 해당 객체만 복사하여 새 객체를 생성한다. 복사된 객체의 인스턴스 변수는 원본 객체의 인스턴스 변수와 같은 메모리 주소를 참조하며 해당 메모리 주소의 값이 변경되면 다른 객체의 변수 값 역시 동일하게 변경된다.var objA = [{ id: 1, name: \"david\" }];var objB = objA;objB.name = \"jeff\";console.log(\"objB--\", objB);console.log(\"objA--\", objA);Test 실행 결과화면깊은 복사(Deep Copy) 객체를 복사할 때 해당 객체와 인스턴스 변수까지 복사한다. 데이터 참조가 아닌 객체의 형태를 그대로 복사함으로써 한 객체가 변경되어도 다른 객체의 데이터에는 영향을 주지 않는다.var objA = { id: 1, a: {name : \"david\"} };var objB = {...objA};objA.id=2;objA['a'].name = \"jeff\";console.log(\"objB--\", objB);console.log(\"objA--\", objA);Test 실행 결과화면objA의 id 값을 재할당하였으나 objB의 id값은 변경되지 않아 깊은 복사가 되었다고 생각할 수 있다. 그러나 결과화면에서 볼 수 있듯이 objA 내부의 {name: “david”} 객체의 값을 변경하였을때 objB 내부의 name 까지 변경되었다.즉, 완벽한 복사는 아니라고 할 수 있다. (Object.assign() 역시 비슷한 결과.)완벽한 깊은 복사 JSON.parse()/JSON.stringity() JSON.stringity 함수를 이용하여 Object 전체를 문자열로 변환한 뒤 다시 JSON.parse 함수를 이용하여 문자열을 Object 형태로 변환한다. 문자열로 변환하는 과정에서 객체에 대한 참조가 사라지며 새로운 객체로 깊은 복사가 가능하다. var objA = [{ id: 1, name: \"david\" }];var objB = JSON.parse(JSON.stringify(objA[0]));objB.name = \"jeff\";console.log(\"objB--\", objB);console.log(\"objA--\", objA);Test 실행 결과화면" }, { "title": "[Javascript] jQuery.extend()", "url": "/posts/Javascript-jQuery.extend()/", "categories": "Programming, JavaScript", "tags": "JavaScript", "date": "2021-04-23 10:00:00 +0900", "snippet": "jQuery.extend() 두개 이상의 객체를 합치는(Merge) 함수 기본적인 형태var object=$.extend([deep], target, object1, object2);var objA = { id: 1};var objB = $.extend({}, objA, { name: \"dahyun\"});console.log(objB);결과화면 deep이 true일 경우 깊은 수준 복사가 가능하다.var objA = { list: [{ id: 1 }]};var objB = $.extend({}, objA, { list: [{ name: \"dahyun\" }]});console.log(objB);var objB = $.extend(true, {}, objA, { list: [{ name: \"dahyun\" }]});console.log(objB);결과화면" }, { "title": "[JavaScript] IIFE (즉시 실행 함수)", "url": "/posts/Javascript-IIFE-(%EC%A6%89%EC%8B%9C-%EC%8B%A4%ED%96%89-%ED%95%A8%EC%88%98)/", "categories": "Programming, JavaScript", "tags": "JavaScript", "date": "2021-04-23 10:00:00 +0900", "snippet": "IIFE (즉시 실행 함수)일단 IIFE를 공부하기전 함수의 선언과 함수의 표현에 대해서 알아보자 !함수 선언식 / 함수 표현식 함수 선언식 함수를 정의하고, 함수를 할당할 변수를 만들지 않는다. 함수 표현식 함수가 변수로 할당될 수 있다. 또한 함수가 익명일 수도 있고, 다른 함수 표현식의 일부가 될 수도 있다. // 함수선언식function hello() {\t// ...};// 함수표현식var hello=function() {\t// ...};IIFE(Immediately Invoked Function Expressions) 정의되자마자 즉시 호출되는 함수 기본적인 형태 (function() {\t// 생략 ...})();(function(name) { // 생략 ...})('dahyun'); 특징 불필요한 전역 변수와 함수를 생성하지 않는다. IIFE안에 존재하는 코드는 외부에서 접근할 수 없다. IIFE에서 생성된 변수와 함수의 이름은 전역 Scope를 오염시키지 않는다.(충돌하지 않는다.) 다양한 표현식!function(a, b) { return console.log(a + b) }(1, 2); // 3void function(a, b) { return console.log(a + b) }(1, 2); // 3+function(a, b) { return console.log(a + b) }(1, 2); // 3-function(a, b) { return console.log(a + b) }(1, 2); // 3~function(a, b) { return console.log(a + b) }(1, 2); // 3*function(a, b) { return console.log(a + b) }(1, 2); // 3^function(a, b) { return console.log(a + b) }(1, 2); // 3&amp;function(a, b) { return console.log(a + b) }(1, 2); // 3" }, { "title": "[Spring] @RequestParam과 @PathVariable", "url": "/posts/Spring-@RequestParam%EA%B3%BC-@PathVariable/", "categories": "Programming, Spring", "tags": "Spring, SpringBoot", "date": "2021-04-22 10:00:00 +0900", "snippet": "@RequestParam과 @PathVariableController에서 데이터를 전달받는 방법controller단에서 데이터를 받아오는 타입에는 여러가지가 있다.ServletRequest, ServletResponse, HttpSession을 이용한 Sevlet API,WebRequest, MultipartRequest를 이용하는 Spring API,그리고 Spring Annotation이 있다.오늘은 그중에서도 Spring Annotation의 @RequestParam과 @PathVariable에 대해서 알아보자!@RequestParam 요청 파라미터를 넣어주는 어노테이션이며 http://localhost:8080?userId=test 형식의 url 주소로 파라미터를 전달받을 수 있다.@GetMapping(value = \"/\")public String test(\t@RequestParam(value = \"userId\", required = false) String userId\t) {}value 값에는 넘어오는 파라미터의 name값을 작성해주고선언한 파라미터가 없는 경우 required = false를 작성하지 않았다면 400 에러가 발생한다.@PathVariable 파라미터를 URL 경로에 포함시키는 방법. 예를 들어 id로 해당하는 정보를 요청할 때의 url은 http://localhost:8080/test 이고 {} 중괄호에 명시된 값을 변수로 받을 수 있다. 주로 RESTful 방식에서 사용된다.@GetMapping(value = \"/{userId}\")public String test(\t@PathVarialble(\"userId\") String userId\t) {} 물론 @RequestParam 또는 @PathVariable 두가지를 복합적으로 사용하는 것도 가능하다" }, { "title": "[Junit] @FixMethodOrder", "url": "/posts/Junit-@FixMethodOrder/", "categories": "Programming, JAVA", "tags": "JAVA, Junit", "date": "2021-04-22 10:00:00 +0900", "snippet": "@FixMethodOrder(Option) Test 메소드 실행 순서의 기준을 지정하는 AnnotationMethodSorters Option MethodSorters.DEFAULT hashcode를 기반으로 순서를 결정한다. 실행 순서를 예측하기 힘들다. MethodSorters.JVM 시스템의 리소스 상황에 따라 다른 순서로 결과를 보낸다. MethodSorters.NAME_ASCENDING 메소드 명을 오름차순으로 정렬한 순서대로 실행된다. @FixMethodOrder(MethodSorters.NAME_ASCENDING)public class JunitOrderTest { @Test public void test1() { System.out.println(\"첫번째로 실행!\"); } @Test public void test2() { System.out.println(\"두번째로 실행!\"); }}Test 실행 결과화면" } ]
