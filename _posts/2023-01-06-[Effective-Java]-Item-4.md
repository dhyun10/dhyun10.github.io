---
title: "[Effective Java] Item 4"
date: 2023-01-06 10:00:00 +0900
categories: [Study, Effective Java]
tags: [Java, Effective Java]
---

# Effective Java - Item 4

<aside>
💡 인스턴스화를 막으려거든 private 생성자를 사용하라

</aside>

## ❓인스턴스화란

> 메소드와 변수를 모아놓은 것에 불과한 클래스를 사용할 수 있도록 해당 클래스 타입의 객체명을 선언하고 값을 넣어 해당 클래스의 변수나 메소드를 사용 가능한 상태로 만드는 것
>

기본 타입 값이나 배열 관련 메서드를 모아 놓을 때 `java.lang.Math`, `java.util.Arrays`

특정 인터페이스를 구현하는 객체를 생성해주는 정적 메소드(혹은 팩토리)를 모아 놓을 때 `java.util.Collections`

final 클래스를 상속해서 하위 클래스에 메서드를 넣는 것은 불가능 하기 때문에 final 클래스와 관련한 메소드를 모아 놓을  때

위의 세가지 경우에 정적 필드와 정적 메소드만을 가진 클래스를 생성할 필요가 있다.

생성자를 명시하지 않으면 컴파일러가 자동으로 기본 생성자를 만들어주기 때문에 원치않는 public 생성자가 만들어지고 사용자는 생성자가 사용하기 위해 만든 생성자인지 아닌지를 구분할 수가 없다.

그렇다고 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다. 하위 클래스를 만들어 사용자가 상속하여 인스턴스화를 할 수 있기 때문이다.

이런 경우에 생성자에 private 생성자를 추가한다.

오직 명시된 생성자가 없을 경우에만 컴파일러가 기본 생성자를 만들기 때문에 클래스 바깥에서는 접근할 수 없는 private 생성자를 추가한다면 인스턴스화를 막을 수 있다.

- 코드

```java
public class UtilityClass {

    private UtilityClass() {
    	throw new AssertionError();
    }
    ...
}
```

→ 무조건 Error를 던져줘야할 필요는 없으나 같은 클래스내에서 실수로라도 생성자를 호출할 수 없도록 해준다.

이런 방식을 사용한다면 상속 역시 불가능하다.

모든 생성자는 상위 클래스의 생성자를 호출하게 되어있는데 접근 권한을 private로 선언한다면 하위 클래스에서 상위 클래스의 생성자에 접근할 방법이 없기 때문이다.
